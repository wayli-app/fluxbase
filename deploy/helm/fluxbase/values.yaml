## @section Global parameters
## @descriptionStart
## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass
## @descriptionEnd

## @param global.imageRegistry Global Docker image registry
## @param global.imagePullSecrets Global Docker registry secret names as an array
## @param global.storageClass Global StorageClass for Persistent Volume(s)
##
global:
  imageRegistry: ""
  ## E.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []
  storageClass: ""

## @section Common parameters

## @param kubeVersion Override Kubernetes version
##
kubeVersion: ""
## @param nameOverride String to partially override common.names.name
##
nameOverride: ""
## @param fullnameOverride String to fully override common.names.fullname
##
fullnameOverride: ""
## @param namespaceOverride String to fully override common.names.namespace
##
namespaceOverride: ""
## @param commonLabels Labels to add to all deployed objects
##
commonLabels: {}
## @param commonAnnotations Annotations to add to all deployed objects
##
commonAnnotations: {}
## @param clusterDomain Kubernetes cluster domain name
##
clusterDomain: cluster.local
## @param extraDeploy Array of extra objects to deploy with the release
##
extraDeploy: []

## @section Fluxbase Image parameters

## Fluxbase image
## @param image.registry [default: docker.io] Fluxbase image registry
## @param image.repository [default: fluxbase/fluxbase] Fluxbase image repository
## @param image.tag Fluxbase image tag (immutable tags are recommended)
## @param image.digest Fluxbase image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
## @param image.pullPolicy Fluxbase image pull policy
## @param image.pullSecrets Fluxbase image pull secrets
##
image:
  registry: ghcr.io
  repository: fluxbase-eu/fluxbase
  # Overrides the image tag whose default is the chart appVersion
  tag: ""
  digest: ""
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
  ##
  pullPolicy: IfNotPresent
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ## e.g:
  ## pullSecrets:
  ##   - myRegistryKeySecretName
  ##
  pullSecrets: []

## @section Fluxbase Configuration parameters
## @descriptionStart
## Complete Fluxbase application configuration.
## This mirrors the structure of fluxbase.yaml.example.
## All settings are passed as environment variables with FLUXBASE_ prefix.
## Generate secrets with: scripts/generate-keys.sh
## @descriptionEnd

## Fluxbase configuration
config:
  ## Server configuration
  ## @param config.server.address Server bind address (host:port)
  ## @param config.server.read_timeout HTTP read timeout
  ## @param config.server.write_timeout HTTP write timeout
  ## @param config.server.idle_timeout HTTP idle timeout
  ## @param config.server.body_limit Maximum request body size in bytes (default 2GB)
  ##
  server:
    address: ":8080"
    read_timeout: "300s"
    write_timeout: "300s"
    idle_timeout: "120s"
    body_limit: 2147483648

  ## Database configuration
  ## Note: host, port, user are auto-determined from postgresql.* section
  ## @param config.database.ssl_mode PostgreSQL SSL mode (disable, allow, prefer, require, verify-ca, verify-full)
  ## @param config.database.max_connections Maximum database connections
  ## @param config.database.min_connections Minimum database connections
  ## @param config.database.max_conn_lifetime Maximum connection lifetime
  ## @param config.database.max_conn_idle_time Maximum connection idle time
  ## @param config.database.health_check_period Health check interval
  ## @param config.database.user_migrations_path Path to user-provided migration files (optional)
  ##
  database:
    ssl_mode: "disable"
    max_connections: 25
    min_connections: 5
    max_conn_lifetime: "1h"
    max_conn_idle_time: "30m"
    health_check_period: "1m"
    user_migrations_path: ""

  ## Authentication configuration
  ## @param config.auth.jwt_secret JWT signing secret (use existingSecret in production)
  ## @param config.auth.anon_key Pre-generated JWT with 'anon' role for client apps (optional, for convenience)
  ## @param config.auth.service_role_key Pre-generated JWT with 'service_role' for backend services (optional, for convenience)
  ## @param config.auth.jwt_expiry Access token expiration
  ## @param config.auth.refresh_expiry Refresh token expiration
  ## @param config.auth.magic_link_expiry Magic link expiration
  ## @param config.auth.password_reset_expiry Password reset link expiration
  ## @param config.auth.password_min_length Minimum password length
  ## @param config.auth.bcrypt_cost Bcrypt hashing cost (4-31, recommended 10-14)
  ## @param config.auth.enable_signup Enable user registration
  ## @param config.auth.enable_magic_link Enable magic link authentication
  ## @param config.auth.totp_issuer TOTP issuer name for 2FA
  ## @param config.auth.google_client_id Google OAuth client ID
  ## @param config.auth.apple_client_id Apple OAuth client ID
  ## @param config.auth.microsoft_client_id Microsoft OAuth client ID
  ##
  auth:
    jwt_secret: "" # Use existingSecret in production. Generate with: scripts/generate-keys.sh
    anon_key: "" # Pre-signed JWT for client apps. Generate with: scripts/generate-keys.sh (option 3)
    service_role_key: "" # Pre-signed JWT for backend services. Generate with: scripts/generate-keys.sh (option 3)
    jwt_expiry: "15m"
    refresh_expiry: "168h"
    magic_link_expiry: "15m"
    password_reset_expiry: "1h"
    password_min_length: 8
    bcrypt_cost: 10
    enable_signup: true
    enable_magic_link: true
    totp_issuer: "Fluxbase"
    google_client_id: ""
    apple_client_id: ""
    microsoft_client_id: ""

  ## Security configuration
  ## @param config.security.enable_global_rate_limit Enable global rate limiting
  ## @param config.security.setup_token Admin setup token (REQUIRED to enable dashboard)
  ## @param config.security.admin_setup_rate_limit Admin setup rate limit (requests)
  ## @param config.security.admin_setup_rate_window Admin setup rate window
  ## @param config.security.auth_login_rate_limit Auth login rate limit (requests)
  ## @param config.security.auth_login_rate_window Auth login rate window
  ## @param config.security.admin_login_rate_limit Admin login rate limit (requests)
  ## @param config.security.admin_login_rate_window Admin login rate window
  ##
  security:
    enable_global_rate_limit: false
    setup_token: "" # Use existingSecret in production. Generate with: openssl rand -base64 32
    admin_setup_rate_limit: 5
    admin_setup_rate_window: "1m"
    auth_login_rate_limit: 10
    auth_login_rate_window: "1m"
    admin_login_rate_limit: 5
    admin_login_rate_window: "1m"

  ## CORS configuration
  ## @param config.cors.allowed_origins Allowed origins for CORS
  ## @param config.cors.allowed_methods Allowed HTTP methods
  ## @param config.cors.allowed_headers Allowed request headers
  ## @param config.cors.exposed_headers Headers exposed to the client
  ## @param config.cors.allow_credentials Allow credentials (cookies, auth headers)
  ## @param config.cors.max_age Preflight cache duration in seconds
  ##
  cors:
    allowed_origins:
      - "*"
    allowed_methods:
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
      - "PATCH"
      - "OPTIONS"
    allowed_headers:
      - "Origin"
      - "Content-Type"
      - "Accept"
      - "Authorization"
      - "X-Request-ID"
      - "X-CSRF-Token"
      - "X-Impersonation-Token"
      - "Prefer"
      - "apikey"
      - "x-client-app"
    exposed_headers:
      - "Content-Range"
      - "Content-Encoding"
      - "Content-Length"
      - "X-Request-ID"
      - "X-RateLimit-Limit"
      - "X-RateLimit-Remaining"
      - "X-RateLimit-Reset"
    allow_credentials: true
    max_age: 86400

  ## Storage configuration
  ## @param config.storage.enabled Enable storage functionality
  ## @param config.storage.provider Storage provider (local or s3)
  ## @param config.storage.local_path Local storage base path
  ## @param config.storage.max_upload_size Maximum upload size in bytes
  ## @param config.storage.default_buckets Default storage buckets to create
  ## @param config.storage.s3_endpoint S3 endpoint URL
  ## @param config.storage.s3_access_key S3 access key (use existingSecret)
  ## @param config.storage.s3_secret_key S3 secret key (use existingSecret)
  ## @param config.storage.s3_bucket S3 bucket name
  ## @param config.storage.s3_region S3 region
  ## @param config.storage.s3_force_path_style Force S3 path-style URLs (for MinIO)
  ##
  storage:
    enabled: true
    provider: "local"
    local_path: "/data/storage"
    max_upload_size: "2147483648" # 2GB
    default_buckets: []
    s3_endpoint: ""
    s3_access_key: "" # Use existingSecret in production
    s3_secret_key: "" # Use existingSecret in production
    s3_bucket: ""
    s3_region: ""
    s3_force_path_style: false

  ## Realtime/WebSocket configuration
  ## @param config.realtime.enabled Enable realtime subscriptions
  ## @param config.realtime.max_connections Maximum WebSocket connections
  ## @param config.realtime.ping_interval WebSocket ping interval
  ## @param config.realtime.pong_timeout WebSocket pong timeout
  ## @param config.realtime.write_buffer_size WebSocket write buffer size
  ## @param config.realtime.read_buffer_size WebSocket read buffer size
  ## @param config.realtime.message_size_limit Maximum message size
  ## @param config.realtime.channel_buffer_size Channel buffer size
  ##
  realtime:
    enabled: true
    max_connections: 1000
    ping_interval: "30s"
    pong_timeout: "60s"
    write_buffer_size: 1024
    read_buffer_size: 1024
    message_size_limit: 524288
    channel_buffer_size: 100

  ## Email configuration
  ## @param config.email.enabled Enable email sending
  ## @param config.email.provider Email provider (smtp, sendgrid, mailgun, ses)
  ## @param config.email.from_address Sender email address
  ## @param config.email.from_name Sender display name
  ## @param config.email.reply_to_address Reply-to email address
  ## @param config.email.smtp_host SMTP server host
  ## @param config.email.smtp_port SMTP server port
  ## @param config.email.smtp_username SMTP username
  ## @param config.email.smtp_password SMTP password (use existingSecret)
  ## @param config.email.smtp_tls Enable SMTP TLS
  ## @param config.email.sendgrid_api_key SendGrid API key (use existingSecret)
  ## @param config.email.mailgun_api_key Mailgun API key (use existingSecret)
  ## @param config.email.mailgun_domain Mailgun domain
  ## @param config.email.ses_access_key AWS SES access key (use existingSecret)
  ## @param config.email.ses_secret_key AWS SES secret key (use existingSecret)
  ## @param config.email.ses_region AWS SES region
  ##
  email:
    enabled: false
    provider: "smtp"
    from_address: "noreply@localhost"
    from_name: "Fluxbase"
    reply_to_address: ""
    smtp_host: ""
    smtp_port: 587
    smtp_username: ""
    smtp_password: "" # Use existingSecret in production
    smtp_tls: true
    sendgrid_api_key: "" # Use existingSecret in production
    mailgun_api_key: "" # Use existingSecret in production
    mailgun_domain: ""
    ses_access_key: "" # Use existingSecret in production
    ses_secret_key: "" # Use existingSecret in production
    ses_region: "us-east-1"

  ## Edge Functions configuration
  ## @param config.functions.enabled Enable edge functions
  ## @param config.functions.functions_dir Functions directory path
  ## @param config.functions.auto_load_on_boot Auto-load functions on startup
  ## @param config.functions.default_timeout Default function timeout (seconds)
  ## @param config.functions.max_timeout Maximum function timeout (seconds)
  ## @param config.functions.default_memory_limit Default memory limit (MB)
  ## @param config.functions.max_memory_limit Maximum memory limit (MB)
  ## @param config.functions.sync_allowed_ip_ranges IP ranges allowed for function sync
  ##
  functions:
    enabled: true
    functions_dir: "/app/functions"
    auto_load_on_boot: true
    default_timeout: 30
    max_timeout: 300
    default_memory_limit: 128
    max_memory_limit: 1024
    sync_allowed_ip_ranges: []

  ## Background Jobs configuration
  ## @param config.jobs.enabled Enable background jobs
  ## @param config.jobs.jobs_dir Jobs directory path
  ## @param config.jobs.auto_load_on_boot Auto-load jobs on startup
  ## @param config.jobs.worker_mode Worker mode (embedded, standalone, disabled)
  ## @param config.jobs.embedded_worker_count Number of embedded workers
  ## @param config.jobs.max_concurrent_per_worker Max concurrent jobs per worker
  ## @param config.jobs.max_concurrent_per_namespace Max concurrent jobs per namespace
  ## @param config.jobs.default_max_duration Default max job duration
  ## @param config.jobs.max_max_duration Maximum allowed job duration
  ## @param config.jobs.default_progress_timeout Default progress timeout
  ## @param config.jobs.poll_interval Job polling interval
  ## @param config.jobs.worker_heartbeat_interval Worker heartbeat interval
  ## @param config.jobs.worker_timeout Worker timeout
  ## @param config.jobs.sync_allowed_ip_ranges IP ranges allowed for job sync
  ## @param config.jobs.functions_logs_retention_days Function logs retention (days)
  ## @param config.jobs.rpc_logs_retention_days RPC logs retention (days)
  ## @param config.jobs.jobs_logs_retention_days Job logs retention (days)
  ##
  jobs:
    enabled: true
    jobs_dir: "/app/jobs"
    auto_load_on_boot: true
    worker_mode: "embedded"
    embedded_worker_count: 4
    max_concurrent_per_worker: 10
    max_concurrent_per_namespace: 50
    default_max_duration: "30m"
    max_max_duration: "24h"
    default_progress_timeout: "5m"
    poll_interval: "1s"
    worker_heartbeat_interval: "10s"
    worker_timeout: "30s"
    sync_allowed_ip_ranges: []
    functions_logs_retention_days: 7
    rpc_logs_retention_days: 7
    jobs_logs_retention_days: 7

  ## REST API configuration
  ## @param config.api.max_page_size Maximum rows per request (-1 for unlimited)
  ## @param config.api.max_total_results Maximum total rows via offset+limit (-1 for unlimited)
  ## @param config.api.default_page_size Default page size when not specified (-1 for no default)
  ##
  api:
    max_page_size: 1000
    max_total_results: 10000
    default_page_size: 1000

  ## Migrations configuration
  ## @param config.migrations.enabled Enable migrations API
  ## @param config.migrations.allowed_ip_ranges IP ranges allowed for migrations
  ## @param config.migrations.require_service_key Require service key for migrations
  ##
  migrations:
    enabled: true
    allowed_ip_ranges: []
    require_service_key: false

  ## RPC configuration
  ## @param config.rpc.enabled Enable RPC procedures
  ## @param config.rpc.procedures_dir Procedures directory path
  ## @param config.rpc.auto_load_on_boot Auto-load procedures on startup
  ## @param config.rpc.default_max_execution_time Default max execution time
  ## @param config.rpc.max_max_execution_time Maximum allowed execution time
  ## @param config.rpc.default_max_rows Default max rows returned
  ## @param config.rpc.sync_allowed_ip_ranges IP ranges allowed for RPC sync
  ##
  rpc:
    enabled: true
    procedures_dir: "/app/procedures"
    auto_load_on_boot: true
    default_max_execution_time: "30s"
    max_max_execution_time: "300s"
    default_max_rows: 1000
    sync_allowed_ip_ranges: []

  ## AI/Chatbot configuration
  ## @param config.ai.enabled Enable AI chatbots
  ## @param config.ai.chatbots_dir Chatbots directory path
  ## @param config.ai.auto_load_on_boot Auto-load chatbots on startup
  ## @param config.ai.default_max_tokens Default max tokens for responses
  ## @param config.ai.default_model Default AI model
  ## @param config.ai.query_timeout Query timeout
  ## @param config.ai.max_rows_per_query Max rows per database query
  ## @param config.ai.conversation_cache_ttl Conversation cache TTL
  ## @param config.ai.max_conversation_turns Max conversation turns
  ## @param config.ai.sync_allowed_ip_ranges IP ranges allowed for AI sync
  ## @param config.ai.provider_type AI provider type (if set, a read-only config-based provider is added)
  ## @param config.ai.provider_name AI provider name
  ## @param config.ai.provider_model AI provider model
  ## @param config.ai.openai_api_key OpenAI API key (use existingSecret)
  ## @param config.ai.openai_organization_id OpenAI organization ID
  ## @param config.ai.openai_base_url OpenAI base URL
  ## @param config.ai.azure_api_key Azure OpenAI API key (use existingSecret)
  ## @param config.ai.azure_endpoint Azure OpenAI endpoint
  ## @param config.ai.azure_deployment_name Azure OpenAI deployment name
  ## @param config.ai.azure_api_version Azure OpenAI API version
  ## @param config.ai.azure_embedding_deployment_name Azure embedding deployment name
  ## @param config.ai.ollama_endpoint Ollama endpoint
  ## @param config.ai.ollama_model Ollama model
  ## @param config.ai.embedding_enabled Enable embeddings
  ## @param config.ai.embedding_provider Embedding provider
  ## @param config.ai.embedding_model Embedding model
  ## @param config.ai.ocr_enabled Enable OCR
  ## @param config.ai.ocr_provider OCR provider
  ## @param config.ai.ocr_languages OCR languages
  ##
  ai:
    enabled: true
    chatbots_dir: "/app/chatbots"
    auto_load_on_boot: true
    default_max_tokens: 4096
    default_model: ""
    query_timeout: "30s"
    max_rows_per_query: 1000
    conversation_cache_ttl: "1h"
    max_conversation_turns: 50
    sync_allowed_ip_ranges: []
    # Provider configuration (if provider_type is set, a read-only config-based provider is added)
    provider_type: ""
    provider_name: ""
    provider_model: ""
    openai_api_key: "" # Use existingSecret in production
    openai_organization_id: ""
    openai_base_url: ""
    azure_api_key: "" # Use existingSecret in production
    azure_endpoint: ""
    azure_deployment_name: ""
    azure_api_version: ""
    azure_embedding_deployment_name: ""
    ollama_endpoint: ""
    ollama_model: ""
    # Embeddings
    embedding_enabled: false
    embedding_provider: ""
    embedding_model: ""
    # OCR
    ocr_enabled: false
    ocr_provider: ""
    ocr_languages: []

  ## Logging configuration
  ## @param config.logging.console_enabled Enable console logging
  ## @param config.logging.console_level Console log level
  ## @param config.logging.console_format Console log format (json or text)
  ## @param config.logging.backend Logging backend (postgres, s3, local)
  ## @param config.logging.s3_bucket S3 bucket for logs
  ## @param config.logging.s3_prefix S3 prefix for logs
  ## @param config.logging.local_path Local path for logs
  ## @param config.logging.batch_size Log batch size
  ## @param config.logging.flush_interval Log flush interval
  ## @param config.logging.buffer_size Log buffer size
  ## @param config.logging.pubsub_enabled Enable log pub/sub
  ## @param config.logging.system_retention_days System log retention (days)
  ## @param config.logging.http_retention_days HTTP log retention (days)
  ## @param config.logging.security_retention_days Security log retention (days)
  ## @param config.logging.execution_retention_days Execution log retention (days)
  ## @param config.logging.ai_retention_days AI log retention (days)
  ## @param config.logging.retention_enabled Enable log retention cleanup
  ## @param config.logging.retention_check_interval Retention check interval
  ##
  logging:
    console_enabled: true
    console_level: "info"
    console_format: "json"
    backend: "postgres"
    s3_bucket: ""
    s3_prefix: ""
    local_path: ""
    batch_size: 100
    flush_interval: "5s"
    buffer_size: 1000
    pubsub_enabled: true
    system_retention_days: 30
    http_retention_days: 7
    security_retention_days: 90
    execution_retention_days: 7
    ai_retention_days: 30
    retention_enabled: true
    retention_check_interval: "1h"

  ## Tracing configuration (OpenTelemetry)
  ## @param config.tracing.enabled Enable OpenTelemetry tracing
  ## @param config.tracing.endpoint OTLP gRPC endpoint
  ## @param config.tracing.service_name Service name for traces
  ## @param config.tracing.environment Environment name
  ## @param config.tracing.sample_rate Sample rate (0.0-1.0)
  ## @param config.tracing.insecure Use insecure connection
  ##
  tracing:
    enabled: false
    endpoint: "localhost:4317"
    service_name: "fluxbase"
    environment: "production"
    sample_rate: 0.1
    insecure: false

  ## Admin dashboard configuration
  ## @param config.admin.enabled Enable admin dashboard UI and API routes
  ## Note: Also requires fluxbase.security.setup_token to be set
  ##
  admin:
    enabled: true

  ## Encryption configuration
  ## @param config.encryption_key Encryption key for credentials stored via dashboard UI
  ## @descriptionStart
  ## Only required if you configure providers (Email, AI) through the admin dashboard instead of secrets/env vars.
  ## Must be exactly 32 characters for AES-256. Generate with: openssl rand -base64 32 | head -c 32
  ## Use existingSecret in production.
  ## @descriptionEnd
  ##
  encryption_key: ""

  ## General configuration
  ## @param config.base_url Internal base URL for server-to-server communication (e.g., http://localhost:8080)
  ## @param config.public_base_url Public base URL for user-facing links (OAuth callbacks, magic links, invitations)
  ## @descriptionStart
  ## If public_base_url is not set, it falls back to base_url.
  ## Set public_base_url when deploying behind a reverse proxy, load balancer, or ingress.
  ## Example: base_url="http://localhost:8080" and public_base_url="https://api.example.com"
  ## @descriptionEnd
  ## @param config.debug Enable debug mode
  ##
  base_url: ""
  public_base_url: ""
  debug: false

## @param existingSecret Name of existing secret containing sensitive configuration
## @descriptionStart
## When using existingSecret, the secret should contain keys matching the names below.
## You can customize key names using the existingSecretKeyRef parameters.
##
## Supported secret keys (all optional, include only what you need):
##
## Authentication & Security:
##   - jwt-secret: JWT signing secret (REQUIRED)
##   - anon-key: Pre-generated JWT with 'anon' role for client apps
##   - service-role-key: Pre-generated JWT with 'service_role' for backend services
##   - setup-token: Admin setup token (REQUIRED to enable dashboard)
##
## Database (only when postgresql.mode=none):
##   - database-password: PostgreSQL database password
##
## Storage (only when storage.provider=s3):
##   - s3-access-key: S3 access key ID
##   - s3-secret-key: S3 secret access key
##
## Email (based on provider):
##   - smtp-password: SMTP password (when email.provider=smtp)
##   - sendgrid-api-key: SendGrid API key (when email.provider=sendgrid)
##   - mailgun-api-key: Mailgun API key (when email.provider=mailgun)
##   - ses-access-key: AWS SES access key (when email.provider=ses)
##   - ses-secret-key: AWS SES secret key (when email.provider=ses)
##
## Encryption (when configuring providers via dashboard):
##   - encryption-key: Encryption key for dashboard-configured credentials (32 chars)
##
## AI (when ai.enabled=true):
##   - openai-api-key: OpenAI API key (when using OpenAI provider)
##   - azure-api-key: Azure OpenAI API key (when using Azure provider)
##
## Example secret creation:
##   kubectl create secret generic fluxbase-secrets \
##     --from-literal=jwt-secret=$(openssl rand -base64 32) \
##     --from-literal=anon-key=<generated-anon-jwt> \
##     --from-literal=service-role-key=<generated-service-role-jwt> \
##     --from-literal=setup-token=$(openssl rand -base64 32) \
##     --from-literal=encryption-key=$(openssl rand -base64 32 | head -c 32) \
##     --from-literal=openai-api-key=sk-xxx
## @descriptionEnd
##
existingSecret: ""

## @param existingSecretKeyRef Custom key names for existingSecret
## @descriptionStart
## Use this to reference secrets that use different key names than the defaults.
## This is useful when integrating with external secret management systems
## (e.g., External Secrets Operator, Vault) that may use different naming conventions.
##
## Example: If your secret has 'JWT_SECRET' instead of 'jwt-secret':
##   existingSecretKeyRef:
##     jwtSecret: "JWT_SECRET"
## @descriptionEnd
##
existingSecretKeyRef:
  ## Authentication & Security
  jwtSecret: "jwt-secret"
  anonKey: "anon-key"
  serviceRoleKey: "service-role-key"
  setupToken: "setup-token"
  ## Database
  databasePassword: "db-password"
  ## Storage (S3)
  s3AccessKey: "s3-access-key"
  s3SecretKey: "s3-secret-key"
  ## Email (for env var overrides)
  smtpPassword: "smtp-password"
  sendgridApiKey: "sendgrid-api-key"
  mailgunApiKey: "mailgun-api-key"
  sesAccessKey: "ses-access-key"
  sesSecretKey: "ses-secret-key"
  ## Encryption (for dashboard-configured credentials)
  encryptionKey: "encryption-key"
  ## AI
  openaiApiKey: "openai-api-key"
  azureApiKey: "azure-api-key"

## @section Security Configuration

## Service Keys Configuration
## Service keys provide elevated privileges that bypass RLS for backend services.
## WARNING: Service keys have full database access. NEVER expose to clients.
##
## To create a service key:
## 1. Generate random key: openssl rand -base64 32
## 2. Format as: sk_live_<random_string> or sk_test_<random_string>
## 3. Hash with bcrypt and store in database (see docs/guides/authentication.md)
##
## @param serviceKey.enabled Enable service key usage in backend pods
## @param serviceKey.existingSecret Name of existing secret containing the service key
## @param serviceKey.secretKey Key name in the secret (default: service-key)
##
serviceKey:
  enabled: false
  existingSecret: "" # Name of Kubernetes secret containing service key
  secretKey: "service-key" # Key name within the secret

## @section Fluxbase Deployment Parameters

## @param replicaCount Number of Fluxbase replicas to deploy
##
replicaCount: 1

## @param updateStrategy.type Fluxbase deployment strategy type
## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
## e.g:
## updateStrategy:
##  type: RollingUpdate
##  rollingUpdate:
##    maxSurge: 25%
##    maxUnavailable: 25%
##
updateStrategy:
  type: RollingUpdate

## @param podLabels Extra labels for Fluxbase pods
## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
##
podLabels: {}
## @param podAnnotations Annotations for Fluxbase pods
## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
##
podAnnotations: {}
## @param podAffinityPreset Pod affinity preset. Ignored if `affinity` is set. Allowed values: `soft` or `hard`
## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
##
podAffinityPreset: ""
## @param podAntiAffinityPreset Pod anti-affinity preset. Ignored if `affinity` is set. Allowed values: `soft` or `hard`
## Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
##
podAntiAffinityPreset: soft
## @param nodeAffinityPreset.type Node affinity preset type. Ignored if `affinity` is set. Allowed values: `soft` or `hard`
## @param nodeAffinityPreset.key Node label key to match. Ignored if `affinity` is set
## @param nodeAffinityPreset.values Node label values to match. Ignored if `affinity` is set
## E.g.
## nodeAffinityPreset:
##   type: hard
##   key: node-label-key
##   values:
##     - node-label-value
##
nodeAffinityPreset:
  type: ""
  key: ""
  values: []
## @param affinity Affinity for Fluxbase pods assignment
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
## NOTE: `podAffinityPreset`, `podAntiAffinityPreset`, and `nodeAffinityPreset` will be ignored when it's set
##
affinity: {}
## @param nodeSelector Node labels for Fluxbase pods assignment
## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
##
nodeSelector: {}
## @param tolerations Tolerations for Fluxbase pods assignment
## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
##
tolerations: []
## @param priorityClassName Fluxbase pods' priorityClassName
##
priorityClassName: ""
## @param schedulerName Name of the k8s scheduler (other than default) for Fluxbase pods
## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
##
schedulerName: ""
## @param topologySpreadConstraints Topology Spread Constraints for pod assignment spread across your cluster among failure-domains
## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/#spread-constraints-for-pods
##
topologySpreadConstraints: []
## @param terminationGracePeriodSeconds Seconds Fluxbase pod needs to terminate gracefully
## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods
##
terminationGracePeriodSeconds: 30

## Configure Container Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
## @param podSecurityContext.enabled Enabled Fluxbase pods' Security Context
## @param podSecurityContext.fsGroup Set Fluxbase pod's Security Context fsGroup
## @param podSecurityContext.fsGroupChangePolicy Set filesystem group change policy
## @param podSecurityContext.sysctls Set kernel settings using the sysctl interface
## @param podSecurityContext.supplementalGroups Set filesystem extra groups
##
podSecurityContext:
  enabled: true
  fsGroup: 1001
  fsGroupChangePolicy: Always
  sysctls: []
  supplementalGroups: []

## Configure Container Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
## @param containerSecurityContext.enabled Enabled containers' Security Context
## @param containerSecurityContext.seLinuxOptions [object,nullable] Set SELinux options in container
## @param containerSecurityContext.runAsUser Set containers' Security Context runAsUser
## @param containerSecurityContext.runAsGroup Set containers' Security Context runAsGroup
## @param containerSecurityContext.runAsNonRoot Set container's Security Context runAsNonRoot
## @param containerSecurityContext.privileged Set container's Security Context privileged
## @param containerSecurityContext.readOnlyRootFilesystem Set container's Security Context readOnlyRootFilesystem
## @param containerSecurityContext.allowPrivilegeEscalation Set container's Security Context allowPrivilegeEscalation
## @param containerSecurityContext.capabilities.drop List of capabilities to be dropped
## @param containerSecurityContext.seccompProfile.type Set container's Security Context seccomp profile
##
containerSecurityContext:
  enabled: true
  seLinuxOptions: null
  runAsUser: 1001
  runAsGroup: 1001
  runAsNonRoot: true
  privileged: false
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  seccompProfile:
    type: RuntimeDefault

## Fluxbase resource requests and limits
## ref: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
## @param resourcesPreset Set container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if resources is set (resources is recommended for production).
## More information: https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15
##
resourcesPreset: "small"
## @param resources Set container requests and limits for different resources like CPU or memory (essential for production workloads)
## Example:
## resources:
##   requests:
##     cpu: 100m
##     memory: 128Mi
##   limits:
##     cpu: 500m
##     memory: 512Mi
##
resources: {}

## Configure Pods probes
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
## @param startupProbe.enabled Enable startupProbe on Fluxbase containers
## @param startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
## @param startupProbe.periodSeconds Period seconds for startupProbe
## @param startupProbe.timeoutSeconds Timeout seconds for startupProbe
## @param startupProbe.failureThreshold Failure threshold for startupProbe
## @param startupProbe.successThreshold Success threshold for startupProbe
##
startupProbe:
  enabled: true
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30
  successThreshold: 1

## @param livenessProbe.enabled Enable livenessProbe on Fluxbase containers
## @param livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
## @param livenessProbe.periodSeconds Period seconds for livenessProbe
## @param livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
## @param livenessProbe.failureThreshold Failure threshold for livenessProbe
## @param livenessProbe.successThreshold Success threshold for livenessProbe
##
livenessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

## @param readinessProbe.enabled Enable readinessProbe on Fluxbase containers
## @param readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
## @param readinessProbe.periodSeconds Period seconds for readinessProbe
## @param readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
## @param readinessProbe.failureThreshold Failure threshold for readinessProbe
## @param readinessProbe.successThreshold Success threshold for readinessProbe
##
readinessProbe:
  enabled: true
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

## @param customStartupProbe Custom startupProbe that overrides the default one
##
customStartupProbe: {}
## @param customLivenessProbe Custom livenessProbe that overrides the default one
##
customLivenessProbe: {}
## @param customReadinessProbe Custom readinessProbe that overrides the default one
##
customReadinessProbe: {}

## @param lifecycleHooks for the Fluxbase container(s) to automate configuration before or after startup
##
lifecycleHooks: {}

## @param command Override default container command (useful when using custom images)
##
command: []
## @param args Override default container args (useful when using custom images)
##
args: []
## @param extraEnvVars Array with extra environment variables to add to Fluxbase nodes
## e.g:
## extraEnvVars:
##   - name: FOO
##     value: "bar"
##
extraEnvVars: []
## @param extraEnvVarsCM Name of existing ConfigMap containing extra env vars for Fluxbase nodes
##
extraEnvVarsCM: ""
## @param extraEnvVarsSecret Name of existing Secret containing extra env vars for Fluxbase nodes
##
extraEnvVarsSecret: ""

## @param extraVolumes Optionally specify extra list of additional volumes for the Fluxbase pod(s)
## e.g:
## extraVolumes:
##   - name: extra-volume
##     emptyDir: {}
##
extraVolumes: []
## @param extraVolumeMounts Optionally specify extra list of additional volumeMounts for the Fluxbase container(s)
## e.g:
## extraVolumeMounts:
##   - name: extra-volume
##     mountPath: /extra/path
##
extraVolumeMounts: []

## @param initContainers Add additional init containers to the Fluxbase pod(s)
## ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
## e.g:
## initContainers:
##   - name: your-image-name
##     image: your-image
##     imagePullPolicy: Always
##     command: ['sh', '-c', 'echo "hello world"']
##
initContainers: []
## @param sidecars Add additional sidecar containers to the Fluxbase pod(s)
## e.g:
## sidecars:
##   - name: your-image-name
##     image: your-image
##     imagePullPolicy: Always
##     ports:
##       - name: portname
##         containerPort: 1234
##
sidecars: []

## @section Traffic Exposure Parameters

## Fluxbase service parameters
##
service:
  ## @param service.type Fluxbase service type
  ##
  type: ClusterIP
  ## @param service.ports.http Fluxbase service HTTP port
  ##
  ports:
    http: 8080
  ## @param service.nodePorts.http Node port for HTTP
  ## NOTE: choose port between <30000-32767>
  ##
  nodePorts:
    http: ""
  ## @param service.clusterIP Fluxbase service Cluster IP
  ## e.g.:
  ## clusterIP: None
  ##
  clusterIP: ""
  ## @param service.loadBalancerIP Fluxbase service Load Balancer IP
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer
  ##
  loadBalancerIP: ""
  ## @param service.loadBalancerSourceRanges Fluxbase service Load Balancer sources
  ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
  ## e.g:
  ## loadBalancerSourceRanges:
  ##   - 10.10.10.0/24
  ##
  loadBalancerSourceRanges: []
  ## @param service.externalTrafficPolicy Fluxbase service external traffic policy
  ## ref https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
  ## Note: Only applies to LoadBalancer and NodePort service types
  ##
  externalTrafficPolicy: ""
  ## @param service.annotations Additional custom annotations for Fluxbase service
  ##
  annotations: {}
  ## @param service.extraPorts Extra ports to expose in Fluxbase service (normally used with the `sidecars` value)
  ##
  extraPorts: []
  ## @param service.sessionAffinity Control where client requests go, to the same pod or round-robin
  ## Values: ClientIP or None
  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/
  ##
  sessionAffinity: None
  ## @param service.sessionAffinityConfig Additional settings for the sessionAffinity
  ## sessionAffinityConfig:
  ##   clientIP:
  ##     timeoutSeconds: 300
  ##
  sessionAffinityConfig: {}

## Configure the ingress resource that allows you to access the Fluxbase installation
## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
##
ingress:
  ## @param ingress.enabled Enable ingress record generation for Fluxbase
  ##
  enabled: false
  ## @param ingress.ingressClassName IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
  ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
  ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
  ##
  ingressClassName: ""
  ## @param ingress.pathType Ingress path type
  ##
  pathType: ImplementationSpecific
  ## @param ingress.apiVersion Force Ingress API version (automatically detected if not set)
  ##
  apiVersion: ""
  ## @param ingress.hostname Default host for the ingress record
  ##
  hostname: fluxbase.local
  ## @param ingress.path Default path for the ingress record
  ## NOTE: You may need to set this to '/*' in order to use this with ALB ingress controllers
  ##
  path: /
  ## @param ingress.annotations Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
  ## Use this parameter to set the required annotations for cert-manager, see
  ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
  ## e.g:
  ## annotations:
  ##   cert-manager.io/cluster-issuer: cluster-issuer-name
  ##
  ## Default annotations include WebSocket support settings for NGINX Ingress Controller
  ## These annotations enable WebSocket upgrades for the /realtime endpoint
  ## ref: https://kubernetes.github.io/ingress-nginx/user-guide/miscellaneous/#websockets
  ##
  annotations:
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-body-size: "0"
    ## Required for WebSocket connections - NGINX does not support WebSocket over HTTP/2
    ## (RFC 8441 not implemented, see https://trac.nginx.org/nginx/ticket/1992)
    ## This forces HTTP/1.1 for backend connections which supports the Upgrade header
    nginx.ingress.kubernetes.io/proxy-http-version: "1.1"
    nginx.ingress.kubernetes.io/upstream-hash-by: "$request_uri"
  ## WebSocket configuration for /realtime and /ai/ws endpoints
  ## @param ingress.websocket.enabled Enable dedicated WebSocket routing
  ## @param ingress.websocket.paths List of path prefixes for WebSocket connections
  ##
  websocket:
    enabled: true
    paths:
      - /realtime
      - /ai/ws
  ## @param ingress.tls Enable TLS configuration for the host defined at `ingress.hostname` parameter
  ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
  ## You can:
  ##   - Use the `ingress.secrets` parameter to create this TLS secret
  ##   - Rely on cert-manager to create it by setting the corresponding annotations
  ##   - Rely on Helm to create self-signed certificates by setting `ingress.selfSigned=true`
  ##
  tls: false
  ## @param ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
  ##
  selfSigned: false
  ## @param ingress.extraHosts An array with additional hostname(s) to be covered with the ingress record
  ## e.g:
  ## extraHosts:
  ##   - name: fluxbase.local
  ##     path: /
  ##
  extraHosts: []
  ## @param ingress.extraPaths An array with additional arbitrary paths that may need to be added to the ingress under the main host
  ## e.g:
  ## extraPaths:
  ## - path: /*
  ##   backend:
  ##     serviceName: ssl-redirect
  ##     servicePort: use-annotation
  ##
  extraPaths: []
  ## @param ingress.extraTls TLS configuration for additional hostname(s) to be covered with this ingress record
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  ## e.g:
  ## extraTls:
  ## - hosts:
  ##     - fluxbase.local
  ##   secretName: fluxbase.local-tls
  ##
  extraTls: []
  ## @param ingress.secrets Custom TLS certificates as secrets
  ## NOTE: 'key' and 'certificate' are expected in PEM format
  ## NOTE: 'name' should line up with a 'secretName' set further up
  ## If it is not set and you're using cert-manager, this is unneeded, as it will create a secret for you with valid certificates
  ## If it is not set and you're NOT using cert-manager either, self-signed certificates will be created valid for 365 days
  ## It is also possible to create and manage the certificates outside of this helm chart
  ## Please see README.md for more information
  ## e.g:
  ## secrets:
  ##   - name: fluxbase.local-tls
  ##     key: |-
  ##       -----BEGIN RSA PRIVATE KEY-----
  ##       ...
  ##       -----END RSA PRIVATE KEY-----
  ##     certificate: |-
  ##       -----BEGIN CERTIFICATE-----
  ##       ...
  ##       -----END CERTIFICATE-----
  ##
  secrets: []
  ## @param ingress.extraRules Additional rules to be covered with this ingress record
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
  ## e.g:
  ## extraRules:
  ## - host: example.local
  ##     http:
  ##       path: /
  ##       backend:
  ##         service:
  ##           name: example-svc
  ##           port:
  ##             name: http
  ##
  extraRules: []

## @section HTTPRoute Parameters (Gateway API)
## Configure the Gateway API HTTPRoute resource
## ref: https://gateway-api.sigs.k8s.io/
##
httpRoute:
  ## @param httpRoute.enabled Enable Gateway API HTTPRoute generation for Fluxbase
  ##
  enabled: false
  ## @param httpRoute.routeName Name override for the HTTPRoute resource. Defaults to fullname template.
  ##
  routeName: ""
  ## @param httpRoute.parentRefs References to the Gateway(s) that this HTTPRoute attaches to
  ## e.g:
  ## parentRefs:
  ##   - name: my-gateway
  ##     namespace: gateway-system
  ##     sectionName: https
  ##
  parentRefs: []
  ## @param httpRoute.hostname Hostname for the HTTPRoute
  ##
  hostname: fluxbase.local
  ## @param httpRoute.path Path prefix for routing
  ##
  path: /
  ## @param httpRoute.pathType Path match type (Exact, PathPrefix, RegularExpression)
  ##
  pathType: PathPrefix
  ## @param httpRoute.annotations Additional annotations for the HTTPRoute resource
  ##
  annotations: {}
  ## WebSocket configuration for /realtime and /ai/ws endpoints
  ## Enables proper WebSocket upgrade handling via Gateway API v1.2+ appProtocol
  ## ref: https://gateway-api.sigs.k8s.io/guides/http-routing/#websocket-upgrades
  ## @param httpRoute.websocket.enabled Enable dedicated WebSocket routing
  ## @param httpRoute.websocket.paths List of path prefixes for WebSocket connections
  ##
  websocket:
    enabled: true
    paths:
      - /realtime
      - /ai/ws
  ## Timeout configuration for HTTPRoute rules
  ## Critical for WebSocket connections which are long-lived
  ## @param httpRoute.timeouts.request Total request timeout (use "0s" for no timeout, required for WebSockets)
  ## @param httpRoute.timeouts.backendRequest Backend request timeout
  ##
  timeouts:
    request: "0s"  # No timeout - required for WebSocket connections
    backendRequest: "0s"
  ## Client Settings Policy for NGINX Gateway Fabric
  ## @param httpRoute.clientSettings.enabled Enable ClientSettingsPolicy for body size configuration
  ## @param httpRoute.clientSettings.body.maxSize Maximum request body size (0 = unlimited, or use "2g", "500m", etc.)
  ## @param httpRoute.clientSettings.annotations Additional annotations for the ClientSettingsPolicy resource
  ##
  clientSettings:
    enabled: true
    body:
      maxSize: "0"  # 0 = unlimited, matches Fluxbase default 2GB body limit
    annotations: {}
  ## Upstream Settings Policy for NGINX Gateway Fabric
  ## Configures connection pooling and keepalive for backend connections
  ## Critical for WebSocket connections to prevent premature closure
  ## @param httpRoute.upstreamSettings.enabled Enable UpstreamSettingsPolicy
  ## @param httpRoute.upstreamSettings.zoneSize Shared memory zone size for upstream state
  ## @param httpRoute.upstreamSettings.keepAlive.connections Max idle keepalive connections per worker
  ## @param httpRoute.upstreamSettings.keepAlive.requests Max requests per keepalive connection
  ## @param httpRoute.upstreamSettings.keepAlive.time Max time for keepalive connection
  ## @param httpRoute.upstreamSettings.keepAlive.timeout Idle timeout for keepalive connections
  ## @param httpRoute.upstreamSettings.annotations Additional annotations for the UpstreamSettingsPolicy resource
  ##
  upstreamSettings:
    enabled: true
    zoneSize: "512k"
    keepAlive:
      connections: 100
      requests: 1000
      time: "1h"
      timeout: "60s"
    annotations: {}

## @section Persistence Parameters

## Persistence for storage data (when using local storage provider)
##
persistence:
  ## @param persistence.enabled Enable persistence using Persistent Volume Claims
  ##
  enabled: true
  ## @param persistence.storageClass Storage class of backing PVC
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  storageClass: ""
  ## @param persistence.annotations Persistent Volume Claim annotations
  ##
  annotations: {}
  ## @param persistence.accessModes Persistent Volume Access Modes
  ##
  accessModes:
    - ReadWriteOnce
  ## @param persistence.size Size of data volume
  ##
  size: 8Gi
  ## @param persistence.existingClaim The name of an existing PVC to use for persistence
  ##
  existingClaim: ""
  ## @param persistence.selector Selector to match an existing Persistent Volume for Fluxbase data PVC
  ## If set, the PVC can't have a PV dynamically provisioned for it
  ## E.g.
  ## selector:
  ##   matchLabels:
  ##     app: my-app
  ##
  selector: {}
  ## @param persistence.dataSource Custom PVC data source
  ##
  dataSource: {}

## @section PostgreSQL Parameters
## @descriptionStart
## PostgreSQL deployment configuration
## PostgreSQL can be deployed by Fluxbase or provided externally.
## Set postgresql.enabled=true to deploy PostgreSQL alongside Fluxbase.
## Set postgresql.enabled=false and configure externalDatabase to use an external PostgreSQL.
## @descriptionEnd

## @section PostgreSQL Configuration
## @param postgresql.enabled Deploy PostgreSQL alongside Fluxbase (set to false to use externalDatabase)
## @param postgresql.auth.username PostgreSQL username
## @param postgresql.auth.password PostgreSQL password (use existingSecret in production)
## @param postgresql.auth.database PostgreSQL database name
## @param postgresql.auth.existingSecret Name of existing secret containing PostgreSQL credentials
##
postgresql:
  ## Set to true to deploy PostgreSQL, false to use externalDatabase
  enabled: true

  ## Authentication settings
  ## You can specify runtime credentials, admin credentials, or both.
  ## If only one set is provided, the other will use the same credentials.
  auth:
    ## Runtime user for normal application queries
    username: ~
    password: ~
    ## Admin user for migrations and DDL operations (defaults to runtime user if not set)
    adminUsername: ~
    adminPassword: ~
    ## Database name
    database: ~
    ## Name of existing secret to use instead of creating one
    existingSecret: ""
    ## Keys in the existing secret to use
    secretKeys:
      username: db-username
      password: db-password
      adminUsername: db-admin-username
      adminPassword: db-admin-password
      database: db-name

  ## @param postgresql.image.registry PostgreSQL image registry
  ## @param postgresql.image.repository PostgreSQL image repository
  ## @param postgresql.image.tag PostgreSQL image tag
  ##
  image:
    registry: ghcr.io
    repository: fluxbase-eu/fluxbase-postgres
    tag: "18.1-v1"
    pullPolicy: IfNotPresent

  ## @param postgresql.persistence.enabled Enable persistence for PostgreSQL
  ## @param postgresql.persistence.size Size of PostgreSQL data volume
  ## @param postgresql.persistence.storageClass Storage class for PostgreSQL PVC
  ## @param postgresql.persistence.existingClaim The name of an existing PVC to use for PostgreSQL persistence
  ##
  persistence:
    enabled: true
    size: 8Gi
    storageClass: ""
    accessModes:
      - ReadWriteOnce
    existingClaim: ""

  ## @param postgresql.resources Resource requests and limits for PostgreSQL
  ##
  resources:
    requests:
      cpu: 250m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi

  ## @param postgresql.securityContext Security context for PostgreSQL pod
  ##
  securityContext:
    fsGroup: 999
    runAsUser: 999
    runAsNonRoot: true

## @section External Database Configuration
## Used when postgresql.enabled is set to false
## @param externalDatabase.host Database host (required when postgresql.enabled=false)
## @param externalDatabase.port Database port number
## @param externalDatabase.user Database username
## @param externalDatabase.password Password for the database user (use existingSecret in production)
## @param externalDatabase.database Database name
## @param externalDatabase.existingSecret Name of an existing secret resource containing the database credentials
## @param externalDatabase.existingSecretPasswordKey Name of the key in existingSecret containing the password
##
externalDatabase:
  host: ""
  port: 5432
  user: fluxbase
  password: ""
  database: fluxbase
  existingSecret: ""
  existingSecretPasswordKey: "password"

## @section ServiceAccount Parameters

## @param serviceAccount.create Specifies whether a ServiceAccount should be created
## @param serviceAccount.name The name of the ServiceAccount to use.
## @param serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
## @param serviceAccount.annotations Additional custom annotations for the ServiceAccount
##
serviceAccount:
  create: true
  name: ""
  automountServiceAccountToken: false
  annotations: {}

## @section Horizontal Scaling Parameters
## @descriptionStart
## Configuration for multi-instance deployments.
## These settings enable distributed rate limiting, cross-instance realtime broadcasting,
## and scheduler leader election for running multiple Fluxbase instances.
## @descriptionEnd

## Scaling configuration
## @param scaling.backend Backend for distributed state. Options: 'local' (single instance), 'postgres', 'redis'
## @param scaling.enableLeaderElection Enable scheduler leader election using PostgreSQL advisory locks
##
scaling:
  ## Backend for distributed state (rate limiting, pub/sub)
  ## - local: In-memory storage (default, single instance only)
  ## - postgres: PostgreSQL-backed (multi-instance without extra dependencies)
  ## - redis: Redis-compatible backend (Dragonfly recommended for high scale)
  backend: local

  ## Enable scheduler leader election
  ## When enabled, only one instance will run cron schedulers
  ## Uses PostgreSQL advisory locks (no extra dependencies)
  enableLeaderElection: false

  ## Redis Configuration (Dragonfly recommended)
  ## Only used when backend is 'redis'
  ## Dragonfly is 25x faster than Redis with 80% less memory
  ## Works with: Dragonfly, Redis, Valkey, KeyDB
  redis:
    ## @param scaling.redis.enabled Deploy Dragonfly alongside Fluxbase
    enabled: false

    ## @param scaling.redis.image.registry Dragonfly image registry
    ## @param scaling.redis.image.repository Dragonfly image repository
    ## @param scaling.redis.image.tag Dragonfly image tag
    image:
      registry: docker.dragonflydb.io
      repository: dragonflydb/dragonfly
      tag: latest
      pullPolicy: IfNotPresent

    ## @param scaling.redis.password Dragonfly password (use existingSecret in production)
    password: ""
    ## @param scaling.redis.existingSecret Name of existing secret containing Dragonfly password
    existingSecret: ""
    ## @param scaling.redis.existingSecretKey Key name in the existing secret
    existingSecretKey: "redis-password"

    ## @param scaling.redis.resources Resource requests and limits for Dragonfly
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi

    ## @param scaling.redis.persistence.enabled Enable persistence for Dragonfly
    ## @param scaling.redis.persistence.size Size of Dragonfly data volume
    persistence:
      enabled: false
      size: 1Gi
      storageClass: ""

  ## External Redis configuration
  ## Used when redis.enabled is false but backend is 'redis'
  ## @param scaling.externalRedis.host External Redis/Dragonfly host
  ## @param scaling.externalRedis.port External Redis/Dragonfly port
  ## @param scaling.externalRedis.password External Redis/Dragonfly password
  externalRedis:
    host: ""
    port: 6379
    password: ""
    existingSecret: ""
    existingSecretKey: "redis-password"

## @section Autoscaling Parameters

## Autoscaling configuration
## @param autoscaling.enabled Enable autoscaling for Fluxbase
## @param autoscaling.minReplicas Minimum number of Fluxbase replicas
## @param autoscaling.maxReplicas Maximum number of Fluxbase replicas
## @param autoscaling.targetCPU Target CPU utilization percentage
## @param autoscaling.targetMemory Target Memory utilization percentage
##
autoscaling:
  enabled: false
  minReplicas: 3
  maxReplicas: 11
  targetCPU: 80
  targetMemory: 80

## @section Metrics Parameters

## Prometheus metrics
## @param metrics.enabled Enable Prometheus metrics endpoint
## @param metrics.serviceMonitor.enabled Create ServiceMonitor resource for scraping metrics using PrometheusOperator
## @param metrics.serviceMonitor.namespace Namespace for the ServiceMonitor resource (defaults to the Release Namespace)
## @param metrics.serviceMonitor.interval Interval at which metrics should be scraped
## @param metrics.serviceMonitor.scrapeTimeout Timeout after which the scrape is ended
## @param metrics.serviceMonitor.relabelings Metrics relabelings to add to the scrape endpoint
## @param metrics.serviceMonitor.honorLabels Specify honorLabels parameter to add the scrape endpoint
## @param metrics.serviceMonitor.additionalLabels Additional labels that can be used so ServiceMonitor resource(s) can be discovered by Prometheus
## @param metrics.serviceMonitor.selector Prometheus instance selector labels
##
metrics:
  enabled: true
  serviceMonitor:
    enabled: false
    namespace: ""
    interval: 30s
    scrapeTimeout: 10s
    relabelings: []
    honorLabels: false
    additionalLabels: {}
    selector: {}
## NOTE: OpenTelemetry tracing is now configured via fluxbase.tracing section above
