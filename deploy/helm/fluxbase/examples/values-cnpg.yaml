# Example Helm values for CloudNativePG deployment
# Requires CloudNativePG operator to be installed in the cluster
# Install operator: kubectl apply -f https://raw.githubusercontent.com/cloudnative-pg/cloudnative-pg/release-1.25/releases/cnpg-1.25.0.yaml

# PostgreSQL deployment mode
postgresql:
  mode: cnpg # Use CloudNativePG operator

  # Database credentials
  auth:
    username: fluxbase
    password: fluxbase # CHANGE THIS IN PRODUCTION
    database: fluxbase
    # For production, create a secret and reference it:
    # existingSecret: fluxbase-db-secret

  # CloudNativePG configuration
  cnpg:
    enabled: true

    # High availability: 3 instances with automatic failover
    instances: 3

    # PostgreSQL image
    imageName: "ghcr.io/cloudnative-pg/postgresql:18"

    # Storage per instance
    storage:
      size: 20Gi
      storageClass: "" # Use default storage class

    # Monitoring with Prometheus
    monitoring:
      enabled: true

    # Automated backups to S3
    backup:
      enabled: true
      retentionPolicy: "30d"
      schedule: "0 2 * * *" # Daily at 2 AM
      s3:
        enabled: false # Set to true and configure below for S3 backups
        # bucket: my-backup-bucket
        # region: us-east-1
        # endpoint: ""  # Leave empty for AWS S3, or specify for MinIO/other
        # Create a secret with S3 credentials:
        # kubectl create secret generic fluxbase-backup-s3 \
        #   --from-literal=ACCESS_KEY_ID=xxx \
        #   --from-literal=SECRET_ACCESS_KEY=yyy

    # PgBouncer connection pooler for better connection management
    pooler:
      enabled: true
      instances: 2
      type: rw # read-write pooler
      poolMode: transaction # transaction pooling for better performance
      parameters:
        max_client_conn: "1000"
        default_pool_size: "25"
        pool_mode: "transaction"
        max_db_connections: "100"

# Fluxbase application settings
replicaCount: 5 # More replicas since we have HA database

# Resource allocation
resourcesPreset: "medium"

# Storage for user files
persistence:
  enabled: true
  size: 100Gi

# Functions storage (ReadWriteMany required for multiple replicas)
functionsPersistence:
  enabled: true
  size: 10Gi
  storageClass: "" # May need a storage class that supports RWX
  accessModes:
    - ReadWriteMany

# Fluxbase configuration (mirrors fluxbase.yaml.example structure)
fluxbase:
  # Authentication - REQUIRED
  auth:
    jwt_secret: "" # Generate with: openssl rand -base64 32
    jwt_expiry: "15m"
    refresh_expiry: "168h"
    enable_signup: true

  # Security configuration - REQUIRED
  security:
    setup_token: "" # Generate with: openssl rand -base64 32
    enable_global_rate_limit: true

  # Database connection settings
  database:
    ssl_mode: "require"
    max_connections: 50
    min_connections: 10

  # Storage configuration - using S3 for better scalability
  storage:
    provider: "s3"
    s3_bucket: "fluxbase-storage"
    s3_region: "us-east-1"
    s3_endpoint: "" # Leave empty for AWS S3
    # s3_access_key and s3_secret_key should be in existingSecret

  # Server settings
  server:
    address: ":8080"
    read_timeout: "300s"
    write_timeout: "300s"

  # Realtime/WebSocket
  realtime:
    enabled: true
    max_connections: 5000

  # Edge Functions
  functions:
    enabled: true

  # Jobs
  jobs:
    enabled: true
    embedded_worker_count: 8

  # API limits
  api:
    max_page_size: 1000
    max_total_results: 10000

  # Logging
  logging:
    console_level: "info"
    console_format: "json"

# Use existing secret for sensitive data
# existingSecret: fluxbase-secrets
# Create with:
# kubectl create secret generic fluxbase-secrets \
#   --from-literal=database-password=xxx \
#   --from-literal=jwt-secret=yyy \
#   --from-literal=setup-token=zzz \
#   --from-literal=s3-access-key=aaa \
#   --from-literal=s3-secret-key=bbb

# Ingress configuration
ingress:
  enabled: true
  ingressClassName: nginx
  hostname: api.example.com
  path: /
  pathType: Prefix
  tls: true
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

## Gateway API (alternative to Ingress)
## Uncomment to use Gateway API instead of Ingress
## Remember to set ingress.enabled: false when using Gateway API
# gateway:
#   enabled: true
#   parentRefs:
#     - name: my-gateway
#       namespace: gateway-system
#   hostname: api.example.com
#   path: /
#   pathType: PathPrefix

# Monitoring
metrics:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    additionalLabels:
      prometheus: kube-prometheus

# Autoscaling
autoscaling:
  enabled: true
  minReplicas: 5
  maxReplicas: 20
  targetCPU: 70
  targetMemory: 80

# Pod distribution for high availability
podAntiAffinityPreset: hard # Ensure pods are on different nodes

# Installation:
#
# 1. Install CloudNativePG operator:
#    kubectl apply -f https://raw.githubusercontent.com/cloudnative-pg/cloudnative-pg/release-1.25/releases/cnpg-1.25.0.yaml
#
# 2. Create secrets:
#    kubectl create secret generic fluxbase-secrets \
#      --from-literal=database-password=$(openssl rand -base64 32) \
#      --from-literal=jwt-secret=$(openssl rand -base64 32) \
#      --from-literal=setup-token=$(openssl rand -base64 32) \
#      --from-literal=s3-access-key=YOUR_ACCESS_KEY \
#      --from-literal=s3-secret-key=YOUR_SECRET_KEY
#
# 3. Install Fluxbase:
#    helm install fluxbase ./deploy/helm/fluxbase \
#      -f ./deploy/helm/fluxbase/examples/values-cnpg.yaml \
#      --set existingSecret=fluxbase-secrets
#
# 4. Check CNPG cluster status:
#    kubectl get cluster
#    kubectl describe cluster fluxbase-postgresql
