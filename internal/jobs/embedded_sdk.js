/**
 * Fluxbase Embedded SDK for Job Runtime
 *
 * This file is auto-generated by bundling the TypeScript SDK.
 * DO NOT EDIT MANUALLY - changes will be overwritten.
 *
 * To regenerate: npm run generate:embedded-sdk (from sdk/ directory)
 * Source: sdk/src/*.ts
 *
 * SDK Version: 0.1.0
 * Generated: 2025-12-02T18:03:57.594Z
 *
 * @generated
 */

"use strict";
var _FluxbaseSDK = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // scripts/embedded-entry.js
  var embedded_entry_exports = {};
  __export(embedded_entry_exports, {
    FluxbaseAuth: () => FluxbaseAuth,
    FluxbaseClient: () => FluxbaseClient,
    FluxbaseFetch: () => FluxbaseFetch,
    FluxbaseJobs: () => FluxbaseJobs,
    FluxbaseStorage: () => FluxbaseStorage,
    QueryBuilder: () => QueryBuilder,
    StorageBucket: () => StorageBucket,
    createClient: () => createClient
  });

  // src/fetch.ts
  var FluxbaseFetch = class {
    constructor(baseUrl, options = {}) {
      this.refreshTokenCallback = null;
      this.isRefreshing = false;
      this.refreshPromise = null;
      this.anonKey = null;
      this.baseUrl = baseUrl.replace(/\/$/, "");
      this.defaultHeaders = {
        "Content-Type": "application/json",
        ...options.headers
      };
      this.timeout = options.timeout ?? 3e4;
      this.debug = options.debug ?? false;
    }
    /**
     * Register a callback to refresh the token when a 401 error occurs
     * The callback should return true if refresh was successful, false otherwise
     */
    setRefreshTokenCallback(callback) {
      this.refreshTokenCallback = callback;
    }
    /**
     * Set the anon key for fallback authentication
     * When setAuthToken(null) is called, the Authorization header will be
     * restored to use this anon key instead of being deleted
     */
    setAnonKey(key) {
      this.anonKey = key;
    }
    /**
     * Update the authorization header
     * When token is null, restores to anon key if available
     */
    setAuthToken(token) {
      if (token) {
        this.defaultHeaders["Authorization"] = `Bearer ${token}`;
      } else if (this.anonKey) {
        this.defaultHeaders["Authorization"] = `Bearer ${this.anonKey}`;
      } else {
        delete this.defaultHeaders["Authorization"];
      }
    }
    /**
     * Make an HTTP request
     */
    async request(path, options) {
      return this.requestInternal(path, options, false);
    }
    /**
     * Internal request implementation with retry capability
     */
    async requestInternal(path, options, isRetry) {
      const url = `${this.baseUrl}${path}`;
      const headers = { ...this.defaultHeaders, ...options.headers };
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), options.timeout ?? this.timeout);
      if (this.debug) {
        console.log(`[Fluxbase SDK] ${options.method} ${url}`, options.body);
      }
      try {
        const isFormData = options.body && (options.body.constructor?.name === "FormData" || options.body instanceof FormData);
        const requestHeaders = isFormData ? Object.fromEntries(
          Object.entries(headers).filter(([key]) => key.toLowerCase() !== "content-type")
        ) : headers;
        const response = await fetch(url, {
          method: options.method,
          headers: requestHeaders,
          body: isFormData ? options.body : options.body ? JSON.stringify(options.body) : void 0,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        const contentType = response.headers.get("content-type");
        let data;
        if (contentType?.includes("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (this.debug) {
          console.log(`[Fluxbase SDK] Response:`, response.status, data);
        }
        if (response.status === 401 && !isRetry && !options.skipAutoRefresh && this.refreshTokenCallback) {
          const refreshSuccess = await this.handleTokenRefresh();
          if (refreshSuccess) {
            return this.requestInternal(path, options, true);
          }
        }
        if (!response.ok) {
          const error = new Error(
            typeof data === "object" && data && "error" in data ? String(data.error) : response.statusText
          );
          error.status = response.status;
          error.details = data;
          throw error;
        }
        return data;
      } catch (err) {
        clearTimeout(timeoutId);
        if (err instanceof Error) {
          if (err.name === "AbortError") {
            const timeoutError = new Error("Request timeout");
            timeoutError.status = 408;
            throw timeoutError;
          }
          throw err;
        }
        throw new Error("Unknown error occurred");
      }
    }
    /**
     * Handle token refresh with deduplication
     * Multiple concurrent requests that fail with 401 will share the same refresh operation
     */
    async handleTokenRefresh() {
      if (this.isRefreshing && this.refreshPromise) {
        return this.refreshPromise;
      }
      this.isRefreshing = true;
      this.refreshPromise = this.executeRefresh();
      try {
        return await this.refreshPromise;
      } finally {
        this.isRefreshing = false;
        this.refreshPromise = null;
      }
    }
    /**
     * Execute the actual token refresh
     */
    async executeRefresh() {
      if (!this.refreshTokenCallback) {
        return false;
      }
      try {
        return await this.refreshTokenCallback();
      } catch (error) {
        if (this.debug) {
          console.error("[Fluxbase SDK] Token refresh failed:", error);
        }
        return false;
      }
    }
    /**
     * GET request
     */
    async get(path, options = {}) {
      return this.request(path, { ...options, method: "GET" });
    }
    /**
     * GET request that returns response with headers (for count queries)
     */
    async getWithHeaders(path, options = {}) {
      return this.requestWithHeaders(path, { ...options, method: "GET" });
    }
    /**
     * Make an HTTP request and return response with headers
     */
    async requestWithHeaders(path, options) {
      return this.requestWithHeadersInternal(path, options, false);
    }
    /**
     * Internal request implementation that returns response with headers
     */
    async requestWithHeadersInternal(path, options, isRetry) {
      const url = `${this.baseUrl}${path}`;
      const headers = { ...this.defaultHeaders, ...options.headers };
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), options.timeout ?? this.timeout);
      if (this.debug) {
        console.log(`[Fluxbase SDK] ${options.method} ${url}`, options.body);
      }
      try {
        const isFormData = options.body && (options.body.constructor?.name === "FormData" || options.body instanceof FormData);
        const requestHeaders = isFormData ? Object.fromEntries(
          Object.entries(headers).filter(([key]) => key.toLowerCase() !== "content-type")
        ) : headers;
        const response = await fetch(url, {
          method: options.method,
          headers: requestHeaders,
          body: isFormData ? options.body : options.body ? JSON.stringify(options.body) : void 0,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        const contentType = response.headers.get("content-type");
        let data;
        if (contentType?.includes("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (this.debug) {
          console.log(`[Fluxbase SDK] Response:`, response.status, data);
        }
        if (response.status === 401 && !isRetry && !options.skipAutoRefresh && this.refreshTokenCallback) {
          const refreshSuccess = await this.handleTokenRefresh();
          if (refreshSuccess) {
            return this.requestWithHeadersInternal(path, options, true);
          }
        }
        if (!response.ok) {
          const error = new Error(
            typeof data === "object" && data && "error" in data ? String(data.error) : response.statusText
          );
          error.status = response.status;
          error.details = data;
          throw error;
        }
        return {
          data,
          headers: response.headers,
          status: response.status
        };
      } catch (err) {
        clearTimeout(timeoutId);
        if (err instanceof Error) {
          if (err.name === "AbortError") {
            const timeoutError = new Error("Request timeout");
            timeoutError.status = 408;
            throw timeoutError;
          }
          throw err;
        }
        throw new Error("Unknown error occurred");
      }
    }
    /**
     * POST request
     */
    async post(path, body, options = {}) {
      return this.request(path, { ...options, method: "POST", body });
    }
    /**
     * PUT request
     */
    async put(path, body, options = {}) {
      return this.request(path, { ...options, method: "PUT", body });
    }
    /**
     * PATCH request
     */
    async patch(path, body, options = {}) {
      return this.request(path, { ...options, method: "PATCH", body });
    }
    /**
     * DELETE request
     */
    async delete(path, options = {}) {
      return this.request(path, { ...options, method: "DELETE" });
    }
    /**
     * HEAD request
     */
    async head(path, options = {}) {
      const url = `${this.baseUrl}${path}`;
      const headers = { ...this.defaultHeaders, ...options.headers };
      const response = await fetch(url, {
        method: "HEAD",
        headers
      });
      return response.headers;
    }
  };

  // src/utils/error-handling.ts
  async function wrapAsync(operation) {
    try {
      const data = await operation();
      return { data, error: null };
    } catch (error) {
      return {
        data: null,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  }
  async function wrapAsyncVoid(operation) {
    try {
      await operation();
      return { error: null };
    } catch (error) {
      return {
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  }

  // src/auth.ts
  var AUTH_STORAGE_KEY = "fluxbase.auth.session";
  var AUTO_REFRESH_TICK_THRESHOLD = 10;
  var AUTO_REFRESH_TICK_MINIMUM = 1e3;
  var MAX_REFRESH_RETRIES = 3;
  var MemoryStorage = class {
    constructor() {
      this.store = /* @__PURE__ */ new Map();
    }
    get length() {
      return this.store.size;
    }
    clear() {
      this.store.clear();
    }
    getItem(key) {
      return this.store.get(key) ?? null;
    }
    setItem(key, value) {
      this.store.set(key, value);
    }
    removeItem(key) {
      this.store.delete(key);
    }
    key(index) {
      return [...this.store.keys()][index] ?? null;
    }
  };
  function isLocalStorageAvailable() {
    try {
      if (typeof localStorage === "undefined") {
        return false;
      }
      const testKey = "__fluxbase_storage_test__";
      localStorage.setItem(testKey, "test");
      localStorage.removeItem(testKey);
      return true;
    } catch {
      return false;
    }
  }
  var FluxbaseAuth = class {
    constructor(fetch2, autoRefresh = true, persist = true) {
      this.session = null;
      this.refreshTimer = null;
      this.stateChangeListeners = /* @__PURE__ */ new Set();
      this.storage = null;
      this.fetch = fetch2;
      this.persist = persist;
      this.autoRefresh = autoRefresh;
      this.fetch.setRefreshTokenCallback(async () => {
        const result = await this.refreshSession();
        return !result.error;
      });
      if (this.persist) {
        if (isLocalStorageAvailable()) {
          this.storage = localStorage;
        } else {
          this.storage = new MemoryStorage();
        }
      }
      if (this.storage) {
        const stored = this.storage.getItem(AUTH_STORAGE_KEY);
        if (stored) {
          try {
            this.session = JSON.parse(stored);
            if (this.session) {
              this.fetch.setAuthToken(this.session.access_token);
              this.scheduleTokenRefresh();
            }
          } catch {
            this.storage.removeItem(AUTH_STORAGE_KEY);
          }
        }
      }
    }
    /**
     * Get the current session (Supabase-compatible)
     * Returns the session from the client-side cache without making a network request
     */
    async getSession() {
      return { data: { session: this.session }, error: null };
    }
    /**
     * Get the current user (Supabase-compatible)
     * Returns the user from the client-side session without making a network request
     * For server-side validation, use getCurrentUser() instead
     */
    async getUser() {
      return { data: { user: this.session?.user ?? null }, error: null };
    }
    /**
     * Get the current access token
     */
    getAccessToken() {
      return this.session?.access_token ?? null;
    }
    /**
     * Listen to auth state changes (Supabase-compatible)
     * @param callback - Function called when auth state changes
     * @returns Object containing subscription data
     *
     * @example
     * ```typescript
     * const { data: { subscription } } = client.auth.onAuthStateChange((event, session) => {
     *   console.log('Auth event:', event, session)
     * })
     *
     * // Later, to unsubscribe:
     * subscription.unsubscribe()
     * ```
     */
    onAuthStateChange(callback) {
      this.stateChangeListeners.add(callback);
      const subscription = {
        unsubscribe: () => {
          this.stateChangeListeners.delete(callback);
        }
      };
      return { data: { subscription } };
    }
    /**
     * Start the automatic token refresh timer
     * This is called automatically when autoRefresh is enabled and a session exists
     * Only works in browser environments
     */
    startAutoRefresh() {
      this.scheduleTokenRefresh();
    }
    /**
     * Stop the automatic token refresh timer
     * Call this when you want to disable auto-refresh without signing out
     */
    stopAutoRefresh() {
      if (this.refreshTimer) {
        clearTimeout(this.refreshTimer);
        this.refreshTimer = null;
      }
    }
    /**
     * Sign in with email and password (Supabase-compatible)
     * Returns { user, session } if successful, or SignInWith2FAResponse if 2FA is required
     */
    async signIn(credentials) {
      return wrapAsync(async () => {
        const response = await this.fetch.post("/api/v1/auth/signin", credentials);
        if ("requires_2fa" in response && response.requires_2fa) {
          return response;
        }
        const authResponse = response;
        const session = {
          ...authResponse,
          expires_at: Date.now() + authResponse.expires_in * 1e3
        };
        this.setSessionInternal(session);
        return { user: session.user, session };
      });
    }
    /**
     * Sign in with email and password (Supabase-compatible)
     * Alias for signIn() to maintain compatibility with common authentication patterns
     * Returns { user, session } if successful, or SignInWith2FAResponse if 2FA is required
     */
    async signInWithPassword(credentials) {
      return this.signIn(credentials);
    }
    /**
     * Sign up with email and password (Supabase-compatible)
     * Returns session when email confirmation is disabled
     * Returns null session when email confirmation is required
     */
    async signUp(credentials) {
      return wrapAsync(async () => {
        const requestBody = {
          email: credentials.email,
          password: credentials.password
        };
        if (credentials.options?.data) {
          requestBody.user_metadata = credentials.options.data;
        }
        const response = await this.fetch.post(
          "/api/v1/auth/signup",
          requestBody
        );
        if (response.access_token && response.refresh_token) {
          const session = {
            ...response,
            expires_at: Date.now() + response.expires_in * 1e3
          };
          this.setSessionInternal(session);
          return { user: response.user, session };
        }
        return { user: response.user, session: null };
      });
    }
    /**
     * Sign out the current user
     */
    async signOut() {
      return wrapAsyncVoid(async () => {
        try {
          await this.fetch.post("/api/v1/auth/signout");
        } finally {
          this.clearSession();
        }
      });
    }
    /**
     * Refresh the session (Supabase-compatible)
     * Returns a new session with refreshed tokens
     */
    async refreshSession() {
      return wrapAsync(async () => {
        if (!this.session?.refresh_token) {
          throw new Error("No refresh token available");
        }
        const response = await this.fetch.post(
          "/api/v1/auth/refresh",
          {
            refresh_token: this.session.refresh_token
          },
          { skipAutoRefresh: true }
          // Prevent infinite loop on 401
        );
        const session = {
          ...response,
          user: response.user ?? this.session.user,
          expires_at: Date.now() + response.expires_in * 1e3
        };
        this.setSessionInternal(session, "TOKEN_REFRESHED");
        return { user: session.user, session };
      });
    }
    /**
     * Refresh the session (Supabase-compatible alias)
     * Alias for refreshSession() to maintain compatibility with Supabase naming
     * Returns a new session with refreshed tokens
     */
    async refreshToken() {
      return this.refreshSession();
    }
    /**
     * Get the current user from the server
     */
    async getCurrentUser() {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        const user = await this.fetch.get("/api/v1/auth/user");
        return { user };
      });
    }
    /**
     * Update the current user (Supabase-compatible)
     * @param attributes - User attributes to update (email, password, data for metadata)
     */
    async updateUser(attributes) {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        const requestBody = {};
        if (attributes.email) {
          requestBody.email = attributes.email;
        }
        if (attributes.password) {
          requestBody.password = attributes.password;
        }
        if (attributes.data) {
          requestBody.user_metadata = attributes.data;
        }
        if (attributes.nonce) {
          requestBody.nonce = attributes.nonce;
        }
        const user = await this.fetch.patch(
          "/api/v1/auth/user",
          requestBody
        );
        if (this.session) {
          this.session.user = user;
          this.saveSession();
          this.emitAuthChange("USER_UPDATED", this.session);
        }
        return { user };
      });
    }
    /**
     * Set the session manually (Supabase-compatible)
     * Useful for restoring a session from storage or SSR scenarios
     * @param session - Object containing access_token and refresh_token
     * @returns Promise with session data
     */
    async setSession(session) {
      return wrapAsync(async () => {
        const authSession = {
          access_token: session.access_token,
          refresh_token: session.refresh_token,
          user: null,
          // Will be populated by getCurrentUser
          expires_in: 3600,
          // Default, will be updated on refresh
          expires_at: Date.now() + 3600 * 1e3
        };
        this.fetch.setAuthToken(session.access_token);
        const user = await this.fetch.get("/api/v1/auth/user");
        authSession.user = user;
        this.setSessionInternal(authSession, "SIGNED_IN");
        return { user, session: authSession };
      });
    }
    /**
     * Setup 2FA for the current user (Supabase-compatible)
     * Enrolls a new MFA factor and returns TOTP details
     * @param issuer - Optional custom issuer name for the QR code (e.g., "MyApp"). If not provided, uses server default.
     * @returns Promise with factor id, type, and TOTP setup details
     */
    async setup2FA(issuer) {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        return await this.fetch.post(
          "/api/v1/auth/2fa/setup",
          issuer ? { issuer } : void 0
        );
      });
    }
    /**
     * Enable 2FA after verifying the TOTP code (Supabase-compatible)
     * Verifies the TOTP code and returns new tokens with MFA session
     * @param code - TOTP code from authenticator app
     * @returns Promise with access_token, refresh_token, and user
     */
    async enable2FA(code) {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        return await this.fetch.post(
          "/api/v1/auth/2fa/enable",
          { code }
        );
      });
    }
    /**
     * Disable 2FA for the current user (Supabase-compatible)
     * Unenrolls the MFA factor
     * @param password - User password for confirmation
     * @returns Promise with unenrolled factor id
     */
    async disable2FA(password) {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        return await this.fetch.post(
          "/api/v1/auth/2fa/disable",
          { password }
        );
      });
    }
    /**
     * Check 2FA status for the current user (Supabase-compatible)
     * Lists all enrolled MFA factors
     * @returns Promise with all factors and TOTP factors
     */
    async get2FAStatus() {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        return await this.fetch.get(
          "/api/v1/auth/2fa/status"
        );
      });
    }
    /**
     * Verify 2FA code during login (Supabase-compatible)
     * Call this after signIn returns requires_2fa: true
     * @param request - User ID and TOTP code
     * @returns Promise with access_token, refresh_token, and user
     */
    async verify2FA(request) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/auth/2fa/verify",
          request
        );
        if (response.access_token && response.refresh_token) {
          const session = {
            user: response.user,
            access_token: response.access_token,
            refresh_token: response.refresh_token,
            expires_in: response.expires_in || 3600,
            expires_at: Date.now() + (response.expires_in || 3600) * 1e3
          };
          this.setSessionInternal(session, "MFA_CHALLENGE_VERIFIED");
        }
        return response;
      });
    }
    /**
     * Send password reset email (Supabase-compatible)
     * Sends a password reset link to the provided email address
     * @param email - Email address to send reset link to
     * @returns Promise with OTP-style response
     */
    async sendPasswordReset(email) {
      return wrapAsync(async () => {
        await this.fetch.post("/api/v1/auth/password/reset", { email });
        return { user: null, session: null };
      });
    }
    /**
     * Supabase-compatible alias for sendPasswordReset()
     * @param email - Email address to send reset link to
     * @param _options - Optional redirect configuration (currently not used)
     * @returns Promise with OTP-style response
     */
    async resetPasswordForEmail(email, _options) {
      return this.sendPasswordReset(email);
    }
    /**
     * Verify password reset token
     * Check if a password reset token is valid before allowing password reset
     * @param token - Password reset token to verify
     */
    async verifyResetToken(token) {
      return wrapAsync(async () => {
        return await this.fetch.post(
          "/api/v1/auth/password/reset/verify",
          {
            token
          }
        );
      });
    }
    /**
     * Reset password with token (Supabase-compatible)
     * Complete the password reset process with a valid token
     * @param token - Password reset token
     * @param newPassword - New password to set
     * @returns Promise with user and new session
     */
    async resetPassword(token, newPassword) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/auth/password/reset/confirm",
          {
            token,
            new_password: newPassword
          }
        );
        const session = {
          ...response,
          expires_at: Date.now() + response.expires_in * 1e3
        };
        this.setSessionInternal(session, "PASSWORD_RECOVERY");
        return { user: session.user, session };
      });
    }
    /**
     * Send magic link for passwordless authentication (Supabase-compatible)
     * @param email - Email address to send magic link to
     * @param options - Optional configuration for magic link
     * @returns Promise with OTP-style response
     */
    async sendMagicLink(email, options) {
      return wrapAsync(async () => {
        await this.fetch.post("/api/v1/auth/magiclink", {
          email,
          redirect_to: options?.redirect_to
        });
        return { user: null, session: null };
      });
    }
    /**
     * Verify magic link token and sign in
     * @param token - Magic link token from email
     */
    async verifyMagicLink(token) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/auth/magiclink/verify",
          {
            token
          }
        );
        const session = {
          ...response,
          expires_at: Date.now() + response.expires_in * 1e3
        };
        this.setSessionInternal(session);
        return { user: session.user, session };
      });
    }
    /**
     * Sign in anonymously
     * Creates a temporary anonymous user session
     */
    async signInAnonymously() {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/auth/signin/anonymous"
        );
        const session = {
          ...response,
          expires_at: Date.now() + response.expires_in * 1e3
        };
        this.setSessionInternal(session);
        return { user: session.user, session };
      });
    }
    /**
     * Get list of enabled OAuth providers
     */
    async getOAuthProviders() {
      return wrapAsync(async () => {
        return await this.fetch.get(
          "/api/v1/auth/oauth/providers"
        );
      });
    }
    /**
     * Get OAuth authorization URL for a provider
     * @param provider - OAuth provider name (e.g., 'google', 'github')
     * @param options - Optional OAuth configuration
     */
    async getOAuthUrl(provider, options) {
      return wrapAsync(async () => {
        const params = new URLSearchParams();
        if (options?.redirect_to) {
          params.append("redirect_to", options.redirect_to);
        }
        if (options?.scopes && options.scopes.length > 0) {
          params.append("scopes", options.scopes.join(","));
        }
        const queryString = params.toString();
        const url = queryString ? `/api/v1/auth/oauth/${provider}/authorize?${queryString}` : `/api/v1/auth/oauth/${provider}/authorize`;
        const response = await this.fetch.get(url);
        return response;
      });
    }
    /**
     * Exchange OAuth authorization code for session
     * This is typically called in your OAuth callback handler
     * @param code - Authorization code from OAuth callback
     */
    async exchangeCodeForSession(code) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/auth/oauth/callback",
          { code }
        );
        const session = {
          ...response,
          expires_at: Date.now() + response.expires_in * 1e3
        };
        this.setSessionInternal(session);
        return { user: session.user, session };
      });
    }
    /**
     * Convenience method to initiate OAuth sign-in
     * Redirects the user to the OAuth provider's authorization page
     * @param provider - OAuth provider name (e.g., 'google', 'github')
     * @param options - Optional OAuth configuration
     */
    async signInWithOAuth(provider, options) {
      return wrapAsync(async () => {
        const result = await this.getOAuthUrl(provider, options);
        if (result.error) {
          throw result.error;
        }
        const url = result.data.url;
        if (typeof window !== "undefined") {
          window.location.href = url;
        } else {
          throw new Error(
            "signInWithOAuth can only be called in a browser environment"
          );
        }
        return { provider, url };
      });
    }
    /**
     * Sign in with OTP (One-Time Password) - Supabase-compatible
     * Sends a one-time password via email or SMS for passwordless authentication
     * @param credentials - Email or phone number and optional configuration
     * @returns Promise with OTP-style response
     */
    async signInWithOtp(credentials) {
      return wrapAsync(async () => {
        await this.fetch.post("/api/v1/auth/otp/signin", credentials);
        return { user: null, session: null };
      });
    }
    /**
     * Verify OTP (One-Time Password) - Supabase-compatible
     * Verify OTP tokens for various authentication flows
     * @param params - OTP verification parameters including token and type
     * @returns Promise with user and session if successful
     */
    async verifyOtp(params) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/auth/otp/verify",
          params
        );
        if (response.access_token && response.refresh_token) {
          const session = {
            ...response,
            expires_at: Date.now() + response.expires_in * 1e3
          };
          this.setSessionInternal(session);
          return { user: response.user, session };
        }
        return { user: response.user, session: null };
      });
    }
    /**
     * Resend OTP (One-Time Password) - Supabase-compatible
     * Resend OTP code when user doesn't receive it
     * @param params - Resend parameters including type and email/phone
     * @returns Promise with OTP-style response
     */
    async resendOtp(params) {
      return wrapAsync(async () => {
        await this.fetch.post("/api/v1/auth/otp/resend", params);
        return { user: null, session: null };
      });
    }
    /**
     * Get user identities (linked OAuth providers) - Supabase-compatible
     * Lists all OAuth identities linked to the current user
     * @returns Promise with list of user identities
     */
    async getUserIdentities() {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        return await this.fetch.get(
          "/api/v1/auth/user/identities"
        );
      });
    }
    /**
     * Link an OAuth identity to current user - Supabase-compatible
     * Links an additional OAuth provider to the existing account
     * @param credentials - Provider to link
     * @returns Promise with OAuth URL to complete linking
     */
    async linkIdentity(credentials) {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        return await this.fetch.post(
          "/api/v1/auth/user/identities",
          credentials
        );
      });
    }
    /**
     * Unlink an OAuth identity from current user - Supabase-compatible
     * Removes a linked OAuth provider from the account
     * @param params - Identity to unlink
     * @returns Promise with void response
     */
    async unlinkIdentity(params) {
      return wrapAsyncVoid(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        await this.fetch.delete(
          `/api/v1/auth/user/identities/${params.identity.id}`
        );
      });
    }
    /**
     * Reauthenticate to get security nonce - Supabase-compatible
     * Get a security nonce for sensitive operations (password change, etc.)
     * @returns Promise with nonce for reauthentication
     */
    async reauthenticate() {
      return wrapAsync(async () => {
        if (!this.session) {
          throw new Error("Not authenticated");
        }
        return await this.fetch.post(
          "/api/v1/auth/reauthenticate"
        );
      });
    }
    /**
     * Sign in with ID token (for native mobile apps) - Supabase-compatible
     * Authenticate using native mobile app ID tokens (Google, Apple)
     * @param credentials - Provider, ID token, and optional nonce
     * @returns Promise with user and session
     */
    async signInWithIdToken(credentials) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/auth/signin/idtoken",
          credentials
        );
        const session = {
          ...response,
          expires_at: Date.now() + response.expires_in * 1e3
        };
        this.setSessionInternal(session);
        return { user: session.user, session };
      });
    }
    /**
     * Internal: Set the session and persist it
     */
    setSessionInternal(session, event = "SIGNED_IN") {
      this.session = session;
      this.fetch.setAuthToken(session.access_token);
      this.saveSession();
      this.scheduleTokenRefresh();
      this.emitAuthChange(event, session);
    }
    /**
     * Internal: Clear the session
     */
    clearSession() {
      this.session = null;
      this.fetch.setAuthToken(null);
      if (this.storage) {
        this.storage.removeItem(AUTH_STORAGE_KEY);
      }
      if (this.refreshTimer) {
        clearTimeout(this.refreshTimer);
        this.refreshTimer = null;
      }
      this.emitAuthChange("SIGNED_OUT", null);
    }
    /**
     * Internal: Save session to storage
     */
    saveSession() {
      if (this.storage && this.session) {
        this.storage.setItem(AUTH_STORAGE_KEY, JSON.stringify(this.session));
      }
    }
    /**
     * Internal: Schedule automatic token refresh
     * Only runs in browser environments when autoRefresh is enabled
     */
    scheduleTokenRefresh() {
      if (!this.autoRefresh || typeof window === "undefined") {
        return;
      }
      if (!this.session?.expires_at) {
        return;
      }
      if (this.refreshTimer) {
        clearTimeout(this.refreshTimer);
        this.refreshTimer = null;
      }
      const expiresAt = this.session.expires_at;
      const now = Date.now();
      const timeUntilExpiry = expiresAt - now;
      const refreshIn = Math.max(
        timeUntilExpiry - AUTO_REFRESH_TICK_THRESHOLD * 1e3,
        AUTO_REFRESH_TICK_MINIMUM
      );
      this.refreshTimer = setTimeout(() => {
        this.attemptRefresh();
      }, refreshIn);
    }
    /**
     * Internal: Attempt to refresh the token with retry logic
     * Uses exponential backoff: 1s, 2s, 4s delays between retries
     */
    async attemptRefresh(retries = MAX_REFRESH_RETRIES) {
      try {
        const result = await this.refreshSession();
        if (result.error) {
          throw result.error;
        }
      } catch (error) {
        if (retries > 0) {
          const delay = Math.pow(2, MAX_REFRESH_RETRIES - retries) * 1e3;
          console.warn(
            `Token refresh failed, retrying in ${delay / 1e3}s (${retries} attempts remaining)`,
            error
          );
          this.refreshTimer = setTimeout(() => {
            this.attemptRefresh(retries - 1);
          }, delay);
        } else {
          console.error(
            "Token refresh failed after all retries, signing out",
            error
          );
          this.clearSession();
        }
      }
    }
    /**
     * Internal: Emit auth state change event to all listeners
     */
    emitAuthChange(event, session) {
      this.stateChangeListeners.forEach((callback) => {
        try {
          callback(event, session);
        } catch (error) {
          console.error("Error in auth state change listener:", error);
        }
      });
    }
  };

  // src/realtime.ts
  var RealtimeChannel = class {
    constructor(url, channelName, token = null, config = {}) {
      this.ws = null;
      this.callbacks = /* @__PURE__ */ new Map();
      this.presenceCallbacks = /* @__PURE__ */ new Map();
      this.broadcastCallbacks = /* @__PURE__ */ new Map();
      this.subscriptionConfig = null;
      this.subscriptionId = null;
      this._presenceState = {};
      this.myPresenceKey = null;
      this.reconnectAttempts = 0;
      this.maxReconnectAttempts = 10;
      this.reconnectDelay = 1e3;
      this.shouldReconnect = true;
      this.heartbeatInterval = null;
      this.pendingAcks = /* @__PURE__ */ new Map();
      this.messageIdCounter = 0;
      this.onTokenRefreshNeeded = null;
      this.isRefreshingToken = false;
      this.url = url;
      this.channelName = channelName;
      this.token = token;
      this.config = config;
    }
    /**
     * Set callback to request a token refresh when connection fails due to auth
     * @internal
     */
    setTokenRefreshCallback(callback) {
      this.onTokenRefreshNeeded = callback;
    }
    // Implementation
    on(event, configOrCallback, callback) {
      if (event === "postgres_changes" && typeof configOrCallback !== "function") {
        const config = configOrCallback;
        this.subscriptionConfig = config;
        const actualCallback = callback;
        const eventType = config.event;
        if (!this.callbacks.has(eventType)) {
          this.callbacks.set(eventType, /* @__PURE__ */ new Set());
        }
        this.callbacks.get(eventType).add(actualCallback);
      } else if (event === "broadcast" && typeof configOrCallback !== "function") {
        const config = configOrCallback;
        const actualCallback = callback;
        if (!this.broadcastCallbacks.has(config.event)) {
          this.broadcastCallbacks.set(config.event, /* @__PURE__ */ new Set());
        }
        this.broadcastCallbacks.get(config.event).add(actualCallback);
      } else if (event === "presence" && typeof configOrCallback !== "function") {
        const config = configOrCallback;
        const actualCallback = callback;
        if (!this.presenceCallbacks.has(config.event)) {
          this.presenceCallbacks.set(config.event, /* @__PURE__ */ new Set());
        }
        this.presenceCallbacks.get(config.event).add(actualCallback);
      } else {
        const actualEvent = event;
        const actualCallback = configOrCallback;
        if (!this.callbacks.has(actualEvent)) {
          this.callbacks.set(actualEvent, /* @__PURE__ */ new Set());
        }
        this.callbacks.get(actualEvent).add(actualCallback);
      }
      return this;
    }
    /**
     * Remove a callback
     */
    off(event, callback) {
      const callbacks = this.callbacks.get(event);
      if (callbacks) {
        callbacks.delete(callback);
      }
      return this;
    }
    /**
     * Subscribe to the channel
     * @param callback - Optional status callback (Supabase-compatible)
     * @param _timeout - Optional timeout in milliseconds (currently unused)
     */
    subscribe(callback, _timeout) {
      this.shouldReconnect = true;
      this.connect();
      if (callback) {
        const checkConnection = () => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            callback("SUBSCRIBED");
          } else if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
            callback("CHANNEL_ERROR", new Error("Failed to connect"));
          } else {
            setTimeout(checkConnection, 100);
          }
        };
        setTimeout(checkConnection, 100);
      }
      return this;
    }
    /**
     * Unsubscribe from the channel
     * @param timeout - Optional timeout in milliseconds
     * @returns Promise resolving to status string (Supabase-compatible)
     */
    async unsubscribe(timeout) {
      this.shouldReconnect = false;
      return new Promise((resolve) => {
        if (this.ws) {
          this.sendMessage({
            type: "unsubscribe",
            channel: this.channelName,
            subscription_id: this.subscriptionId || void 0
          });
          const startTime = Date.now();
          const maxWait = timeout || 5e3;
          const checkDisconnect = () => {
            if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {
              this.disconnect();
              resolve("ok");
            } else if (Date.now() - startTime > maxWait) {
              this.disconnect();
              resolve("timed out");
            } else {
              setTimeout(checkDisconnect, 100);
            }
          };
          setTimeout(checkDisconnect, 100);
        } else {
          resolve("ok");
        }
      });
    }
    /**
     * Send a broadcast message to all subscribers on this channel
     *
     * @param message - Broadcast message with type, event, and payload
     * @returns Promise resolving to status
     *
     * @example
     * ```typescript
     * await channel.send({
     *   type: 'broadcast',
     *   event: 'cursor-pos',
     *   payload: { x: 100, y: 200 }
     * })
     * ```
     */
    async send(message) {
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
        return "error";
      }
      try {
        const messageId = this.config.broadcast?.ack ? `msg_${Date.now()}_${++this.messageIdCounter}` : void 0;
        this.ws.send(
          JSON.stringify({
            type: "broadcast",
            channel: this.channelName,
            event: message.event,
            payload: message.payload,
            ...messageId && { messageId }
          })
        );
        if (this.config.broadcast?.ack && messageId) {
          const ackTimeout = this.config.broadcast.ackTimeout || 5e3;
          return await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              this.pendingAcks.delete(messageId);
              reject(new Error("Acknowledgment timeout"));
            }, ackTimeout);
            this.pendingAcks.set(messageId, {
              resolve: (value) => {
                clearTimeout(timeout);
                this.pendingAcks.delete(messageId);
                resolve(value);
              },
              reject: (reason) => {
                clearTimeout(timeout);
                this.pendingAcks.delete(messageId);
                reject(reason);
              },
              timeout
            });
          }).catch((error) => {
            console.error("[Fluxbase Realtime] Acknowledgment error:", error);
            return "error";
          });
        }
        return "ok";
      } catch (error) {
        console.error("[Fluxbase Realtime] Failed to send broadcast:", error);
        return "error";
      }
    }
    /**
     * Track user presence on this channel
     *
     * @param state - Presence state to track
     * @returns Promise resolving to status
     *
     * @example
     * ```typescript
     * await channel.track({
     *   user_id: 123,
     *   status: 'online'
     * })
     * ```
     */
    async track(state) {
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
        return "error";
      }
      try {
        if (!this.myPresenceKey) {
          this.myPresenceKey = this.config.presence?.key || `presence-${Math.random().toString(36).substr(2, 9)}`;
        }
        this.ws.send(
          JSON.stringify({
            type: "presence",
            channel: this.channelName,
            event: "track",
            payload: {
              key: this.myPresenceKey,
              state
            }
          })
        );
        return "ok";
      } catch (error) {
        console.error("[Fluxbase Realtime] Failed to track presence:", error);
        return "error";
      }
    }
    /**
     * Stop tracking presence on this channel
     *
     * @returns Promise resolving to status
     *
     * @example
     * ```typescript
     * await channel.untrack()
     * ```
     */
    async untrack() {
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
        return "error";
      }
      if (!this.myPresenceKey) {
        return "ok";
      }
      try {
        this.ws.send(
          JSON.stringify({
            type: "presence",
            channel: this.channelName,
            event: "untrack",
            payload: {
              key: this.myPresenceKey
            }
          })
        );
        this.myPresenceKey = null;
        return "ok";
      } catch (error) {
        console.error("[Fluxbase Realtime] Failed to untrack presence:", error);
        return "error";
      }
    }
    /**
     * Get current presence state for all users on this channel
     *
     * @returns Current presence state
     *
     * @example
     * ```typescript
     * const state = channel.presenceState()
     * console.log('Online users:', Object.keys(state).length)
     * ```
     */
    presenceState() {
      return { ...this._presenceState };
    }
    /**
     * Check if the current token is expired or about to expire
     */
    isTokenExpired() {
      if (!this.token) return false;
      try {
        const parts = this.token.split(".");
        if (parts.length !== 3 || !parts[1]) return false;
        const payload = JSON.parse(atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")));
        if (!payload.exp) return false;
        const now = Math.floor(Date.now() / 1e3);
        return payload.exp <= now + 10;
      } catch {
        return true;
      }
    }
    /**
     * Internal: Connect to WebSocket
     */
    connect() {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        return;
      }
      if (this.isTokenExpired() && this.onTokenRefreshNeeded && !this.isRefreshingToken) {
        this.isRefreshingToken = true;
        console.log("[Fluxbase Realtime] Token expired, requesting refresh before connecting");
        this.onTokenRefreshNeeded().then((newToken) => {
          this.isRefreshingToken = false;
          if (newToken) {
            this.token = newToken;
            console.log("[Fluxbase Realtime] Token refreshed, connecting with new token");
          }
          this.connectWithToken();
        }).catch((err) => {
          this.isRefreshingToken = false;
          console.error("[Fluxbase Realtime] Token refresh failed:", err);
          this.connectWithToken();
        });
        return;
      }
      this.connectWithToken();
    }
    /**
     * Internal: Actually establish the WebSocket connection
     */
    connectWithToken() {
      const wsUrl = new URL(this.url);
      wsUrl.protocol = wsUrl.protocol === "https:" ? "wss:" : "ws:";
      wsUrl.pathname = "/realtime";
      if (this.token) {
        wsUrl.searchParams.set("token", this.token);
      }
      this.ws = new WebSocket(wsUrl.toString());
      this.ws.onopen = () => {
        console.log("[Fluxbase Realtime] Connected");
        this.reconnectAttempts = 0;
        const subscribeMessage = {
          type: "subscribe",
          channel: this.channelName
        };
        if (this.subscriptionConfig) {
          subscribeMessage.config = this.subscriptionConfig;
        }
        this.sendMessage(subscribeMessage);
        this.startHeartbeat();
      };
      this.ws.onmessage = (event) => {
        let message;
        try {
          message = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
        } catch (err) {
          console.error("[Fluxbase Realtime] Failed to parse message:", err);
          return;
        }
        try {
          this.handleMessage(message);
        } catch (err) {
          console.error("[Fluxbase Realtime] Error handling message:", err, message);
        }
      };
      this.ws.onerror = (error) => {
        console.error("[Fluxbase Realtime] WebSocket error:", error);
      };
      this.ws.onclose = () => {
        console.log("[Fluxbase Realtime] Disconnected");
        this.stopHeartbeat();
        this.attemptReconnect();
      };
    }
    /**
     * Internal: Disconnect WebSocket
     */
    disconnect() {
      this.stopHeartbeat();
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Internal: Send a message
     */
    sendMessage(message) {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify(message));
      }
    }
    /**
     * Internal: Handle incoming message
     */
    handleMessage(message) {
      switch (message.type) {
        case "heartbeat":
          break;
        case "broadcast":
          if (message.broadcast) {
            this.handleBroadcastMessage(message.broadcast);
          } else if (message.payload) {
            this.handlePostgresChanges(message.payload);
          }
          break;
        case "presence":
          if (message.presence) {
            this.handlePresenceMessage(message.presence);
          }
          break;
        case "ack":
          if (message.messageId && this.pendingAcks.has(message.messageId)) {
            const ackHandler = this.pendingAcks.get(message.messageId);
            if (ackHandler) {
              ackHandler.resolve(message.status || "ok");
            }
          } else if (message.payload && typeof message.payload === "object" && "type" in message.payload) {
            const payload = message.payload;
            if (payload.type === "access_token" && this.pendingAcks.has("access_token")) {
              const ackHandler = this.pendingAcks.get("access_token");
              if (ackHandler) {
                ackHandler.resolve("ok");
                this.pendingAcks.delete("access_token");
              }
              console.log("[Fluxbase Realtime] Token updated successfully");
            } else {
              if (payload.subscription_id) {
                this.subscriptionId = payload.subscription_id;
                console.log("[Fluxbase Realtime] Subscription ID received:", this.subscriptionId);
              } else {
                console.log("[Fluxbase Realtime] Acknowledged:", message);
              }
            }
          } else {
            if (message.payload && typeof message.payload === "object" && "subscription_id" in message.payload) {
              this.subscriptionId = message.payload.subscription_id;
              console.log("[Fluxbase Realtime] Subscription ID received:", this.subscriptionId);
            } else {
              console.log("[Fluxbase Realtime] Acknowledged:", message);
            }
          }
          break;
        case "error":
          console.error("[Fluxbase Realtime] Error:", message.error);
          if (this.pendingAcks.has("access_token")) {
            const ackHandler = this.pendingAcks.get("access_token");
            if (ackHandler) {
              ackHandler.reject(new Error(message.error || "Token update failed"));
              this.pendingAcks.delete("access_token");
            }
          }
          break;
        case "postgres_changes":
          if (message.payload) {
            this.handlePostgresChanges(message.payload);
          }
          break;
      }
    }
    /**
     * Internal: Handle broadcast message
     */
    handleBroadcastMessage(message) {
      const event = message.event;
      const payload = {
        event,
        payload: message.payload
      };
      if (!this.config.broadcast?.self && message.self) {
        return;
      }
      const callbacks = this.broadcastCallbacks.get(event);
      if (callbacks) {
        callbacks.forEach((callback) => callback(payload));
      }
      const wildcardCallbacks = this.broadcastCallbacks.get("*");
      if (wildcardCallbacks) {
        wildcardCallbacks.forEach((callback) => callback(payload));
      }
    }
    /**
     * Internal: Handle presence message
     */
    handlePresenceMessage(message) {
      const event = message.event;
      const payload = {
        event,
        key: message.key,
        newPresences: message.newPresences,
        leftPresences: message.leftPresences,
        currentPresences: message.currentPresences || this._presenceState
      };
      if (message.currentPresences) {
        this._presenceState = message.currentPresences;
      }
      const callbacks = this.presenceCallbacks.get(event);
      if (callbacks) {
        callbacks.forEach((callback) => callback(payload));
      }
    }
    /**
     * Internal: Handle postgres_changes message
     */
    handlePostgresChanges(payload) {
      const supabasePayload = {
        eventType: payload.type || payload.eventType,
        schema: payload.schema,
        table: payload.table,
        commit_timestamp: payload.timestamp || payload.commit_timestamp || (/* @__PURE__ */ new Date()).toISOString(),
        new: payload.new_record || payload.new || payload.record || {},
        old: payload.old_record || payload.old || {},
        errors: payload.errors || null
      };
      const callbacks = this.callbacks.get(supabasePayload.eventType);
      if (callbacks) {
        callbacks.forEach((callback) => callback(supabasePayload));
      }
      const wildcardCallbacks = this.callbacks.get("*");
      if (wildcardCallbacks) {
        wildcardCallbacks.forEach((callback) => callback(supabasePayload));
      }
    }
    /**
     * Internal: Start heartbeat interval
     */
    startHeartbeat() {
      this.stopHeartbeat();
      this.heartbeatInterval = setInterval(() => {
        this.sendMessage({ type: "heartbeat" });
      }, 3e4);
    }
    /**
     * Internal: Stop heartbeat interval
     */
    stopHeartbeat() {
      if (this.heartbeatInterval) {
        clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
      }
    }
    /**
     * Update the authentication token on an existing connection
     * Sends an access_token message to the server to update auth context
     * On failure, silently triggers a reconnect
     *
     * @param token - The new JWT access token
     * @internal
     */
    updateToken(token) {
      this.token = token;
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
        return;
      }
      if (!token) {
        this.disconnect();
        this.connect();
        return;
      }
      const message = {
        type: "access_token",
        token
      };
      try {
        this.ws.send(JSON.stringify(message));
        const timeout = setTimeout(() => {
          console.warn(
            "[Fluxbase Realtime] Token update acknowledgment timeout, reconnecting"
          );
          this.disconnect();
          this.connect();
        }, 5e3);
        this.pendingAcks.set("access_token", {
          resolve: () => {
            clearTimeout(timeout);
          },
          reject: () => {
            clearTimeout(timeout);
            this.disconnect();
            this.connect();
          },
          timeout
        });
      } catch (error) {
        console.error("[Fluxbase Realtime] Failed to send token update:", error);
        this.disconnect();
        this.connect();
      }
    }
    /**
     * Internal: Attempt to reconnect
     */
    attemptReconnect() {
      if (!this.shouldReconnect) {
        return;
      }
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        console.error("[Fluxbase Realtime] Max reconnect attempts reached");
        return;
      }
      this.reconnectAttempts++;
      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
      console.log(
        `[Fluxbase Realtime] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`
      );
      setTimeout(() => {
        this.connect();
      }, delay);
    }
  };
  var FluxbaseRealtime = class {
    constructor(url, token = null) {
      this.channels = /* @__PURE__ */ new Map();
      this.tokenRefreshCallback = null;
      this.url = url;
      this.token = token;
    }
    /**
     * Set callback to request a token refresh when connections fail due to auth
     * This callback should refresh the auth token and return the new access token
     * @internal
     */
    setTokenRefreshCallback(callback) {
      this.tokenRefreshCallback = callback;
      this.channels.forEach((channel) => {
        channel.setTokenRefreshCallback(callback);
      });
    }
    /**
     * Create or get a channel with optional configuration
     *
     * @param channelName - Channel name (e.g., 'table:public.products')
     * @param config - Optional channel configuration
     * @returns RealtimeChannel instance
     *
     * @example
     * ```typescript
     * const channel = realtime.channel('room-1', {
     *   broadcast: { self: true, ack: true },
     *   presence: { key: 'user-123' }
     * })
     * ```
     */
    channel(channelName, config) {
      const configKey = config ? JSON.stringify(config) : "";
      const key = `${channelName}:${configKey}`;
      if (this.channels.has(key)) {
        return this.channels.get(key);
      }
      const channel = new RealtimeChannel(
        this.url,
        channelName,
        this.token,
        config
      );
      if (this.tokenRefreshCallback) {
        channel.setTokenRefreshCallback(this.tokenRefreshCallback);
      }
      this.channels.set(key, channel);
      return channel;
    }
    /**
     * Remove a specific channel
     *
     * @param channel - The channel to remove
     * @returns Promise resolving to status
     *
     * @example
     * ```typescript
     * const channel = realtime.channel('room-1')
     * await realtime.removeChannel(channel)
     * ```
     */
    async removeChannel(channel) {
      await channel.unsubscribe();
      for (const [key, ch] of this.channels.entries()) {
        if (ch === channel) {
          this.channels.delete(key);
          return "ok";
        }
      }
      return "error";
    }
    /**
     * Remove all channels
     */
    removeAllChannels() {
      this.channels.forEach((channel) => channel.unsubscribe());
      this.channels.clear();
    }
    /**
     * Update auth token for all channels
     * Updates both the stored token for new channels and propagates
     * the token to all existing connected channels.
     *
     * @param token - The new auth token
     */
    setAuth(token) {
      this.token = token;
      this.channels.forEach((channel) => {
        channel.updateToken(token);
      });
    }
  };

  // src/storage.ts
  var StorageBucket = class {
    constructor(fetch2, bucketName) {
      this.fetch = fetch2;
      this.bucketName = bucketName;
    }
    /**
     * Upload a file to the bucket
     * @param path - The path/key for the file
     * @param file - The file to upload (File, Blob, or ArrayBuffer)
     * @param options - Upload options
     */
    async upload(path, file, options) {
      try {
        const formData = new FormData();
        const blob = file instanceof ArrayBuffer ? new Blob([file]) : file;
        formData.append("file", blob);
        if (options?.contentType) {
          formData.append("content_type", options.contentType);
        }
        if (options?.metadata) {
          formData.append("metadata", JSON.stringify(options.metadata));
        }
        if (options?.cacheControl) {
          formData.append("cache_control", options.cacheControl);
        }
        if (options?.upsert !== void 0) {
          formData.append("upsert", String(options.upsert));
        }
        let response;
        if (options?.onUploadProgress) {
          response = await this.uploadWithProgress(path, formData, options.onUploadProgress);
        } else {
          response = await this.fetch.request(
            `/api/v1/storage/${this.bucketName}/${path}`,
            {
              method: "POST",
              body: formData,
              headers: {}
              // Let browser set Content-Type for FormData
            }
          );
        }
        return {
          data: {
            id: response.id || response.key || path,
            path,
            fullPath: `${this.bucketName}/${path}`
          },
          error: null
        };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Upload with progress tracking using XMLHttpRequest
     * @private
     */
    uploadWithProgress(path, formData, onProgress) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const url = `${this.fetch["baseUrl"]}/api/v1/storage/${this.bucketName}/${path}`;
        xhr.upload.addEventListener("progress", (event) => {
          if (event.lengthComputable) {
            const percentage = Math.round(event.loaded / event.total * 100);
            onProgress({
              loaded: event.loaded,
              total: event.total,
              percentage
            });
          }
        });
        xhr.addEventListener("load", () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const response = JSON.parse(xhr.responseText);
              resolve(response);
            } catch (e) {
              resolve(xhr.responseText);
            }
          } else {
            try {
              const errorData = JSON.parse(xhr.responseText);
              reject(new Error(errorData.error || xhr.statusText));
            } catch (e) {
              reject(new Error(xhr.statusText));
            }
          }
        });
        xhr.addEventListener("error", () => {
          reject(new Error("Upload failed"));
        });
        xhr.addEventListener("abort", () => {
          reject(new Error("Upload aborted"));
        });
        xhr.open("POST", url);
        const headers = this.fetch["defaultHeaders"];
        for (const [key, value] of Object.entries(headers)) {
          if (key.toLowerCase() !== "content-type") {
            xhr.setRequestHeader(key, value);
          }
        }
        xhr.send(formData);
      });
    }
    async download(path, options) {
      try {
        const controller = new AbortController();
        let timeoutId;
        if (options?.signal) {
          if (options.signal.aborted) {
            return { data: null, error: new Error("Download aborted") };
          }
          options.signal.addEventListener("abort", () => controller.abort(), {
            once: true
          });
        }
        const timeout = options?.timeout ?? (options?.stream ? 0 : 3e4);
        if (timeout > 0) {
          timeoutId = setTimeout(() => controller.abort(), timeout);
        }
        try {
          const response = await fetch(
            `${this.fetch["baseUrl"]}/api/v1/storage/${this.bucketName}/${path}`,
            {
              headers: this.fetch["defaultHeaders"],
              signal: controller.signal
            }
          );
          if (timeoutId) clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`Failed to download file: ${response.statusText}`);
          }
          if (options?.stream) {
            if (!response.body) {
              throw new Error("Response body is not available for streaming");
            }
            const contentLength = response.headers.get("content-length");
            const size = contentLength ? parseInt(contentLength, 10) : null;
            return {
              data: { stream: response.body, size },
              error: null
            };
          }
          const blob = await response.blob();
          return { data: blob, error: null };
        } catch (err) {
          if (timeoutId) clearTimeout(timeoutId);
          if (err instanceof Error && err.name === "AbortError") {
            if (options?.signal?.aborted) {
              return { data: null, error: new Error("Download aborted") };
            }
            return { data: null, error: new Error("Download timeout") };
          }
          throw err;
        }
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Download a file with resumable chunked downloads for large files.
     * Returns a ReadableStream that abstracts the chunking internally.
     *
     * Features:
     * - Downloads file in chunks using HTTP Range headers
     * - Automatically retries failed chunks with exponential backoff
     * - Reports progress via callback
     * - Falls back to regular streaming if Range not supported
     *
     * @param path - The file path within the bucket
     * @param options - Download options including chunk size, retries, and progress callback
     * @returns A ReadableStream and file size (consumer doesn't need to know about chunking)
     *
     * @example
     * ```typescript
     * const { data, error } = await storage.from('bucket').downloadResumable('large.json', {
     *   chunkSize: 5 * 1024 * 1024, // 5MB chunks
     *   maxRetries: 3,
     *   onProgress: (progress) => console.log(`${progress.percentage}% complete`)
     * });
     * if (data) {
     *   console.log(`File size: ${data.size} bytes`);
     *   // Process data.stream...
     * }
     * ```
     */
    async downloadResumable(path, options) {
      try {
        const chunkSize = options?.chunkSize ?? 5 * 1024 * 1024;
        const maxRetries = options?.maxRetries ?? 3;
        const retryDelayMs = options?.retryDelayMs ?? 1e3;
        const chunkTimeout = options?.chunkTimeout ?? 3e4;
        const url = `${this.fetch["baseUrl"]}/api/v1/storage/${this.bucketName}/${path}`;
        const headers = this.fetch["defaultHeaders"];
        if (options?.signal?.aborted) {
          return { data: null, error: new Error("Download aborted") };
        }
        const headResponse = await fetch(url, {
          method: "HEAD",
          headers,
          signal: options?.signal
        });
        if (!headResponse.ok) {
          throw new Error(`Failed to get file info: ${headResponse.statusText}`);
        }
        const contentLength = headResponse.headers.get("content-length");
        const acceptRanges = headResponse.headers.get("accept-ranges");
        const totalSize = contentLength ? parseInt(contentLength, 10) : null;
        if (acceptRanges !== "bytes") {
          const { data, error } = await this.download(path, {
            stream: true,
            timeout: 0,
            signal: options?.signal
          });
          if (error) return { data: null, error };
          return {
            data,
            error: null
          };
        }
        let downloadedBytes = 0;
        let currentChunk = 0;
        const totalChunks = totalSize ? Math.ceil(totalSize / chunkSize) : null;
        let lastProgressTime = Date.now();
        let lastProgressBytes = 0;
        const stream = new ReadableStream({
          async pull(controller) {
            if (options?.signal?.aborted) {
              controller.error(new Error("Download aborted"));
              return;
            }
            if (totalSize !== null && downloadedBytes >= totalSize) {
              controller.close();
              return;
            }
            const rangeStart = downloadedBytes;
            const rangeEnd = totalSize !== null ? Math.min(downloadedBytes + chunkSize - 1, totalSize - 1) : downloadedBytes + chunkSize - 1;
            let retryCount = 0;
            let chunk = null;
            while (retryCount <= maxRetries && chunk === null) {
              try {
                if (options?.signal?.aborted) {
                  controller.error(new Error("Download aborted"));
                  return;
                }
                const chunkController = new AbortController();
                const timeoutId = setTimeout(
                  () => chunkController.abort(),
                  chunkTimeout
                );
                if (options?.signal) {
                  options.signal.addEventListener(
                    "abort",
                    () => chunkController.abort(),
                    { once: true }
                  );
                }
                const chunkResponse = await fetch(url, {
                  headers: {
                    ...headers,
                    Range: `bytes=${rangeStart}-${rangeEnd}`
                  },
                  signal: chunkController.signal
                });
                clearTimeout(timeoutId);
                if (!chunkResponse.ok && chunkResponse.status !== 206) {
                  throw new Error(
                    `Chunk download failed: ${chunkResponse.statusText}`
                  );
                }
                const arrayBuffer = await chunkResponse.arrayBuffer();
                chunk = new Uint8Array(arrayBuffer);
                if (totalSize === null && chunk.byteLength < chunkSize) {
                  downloadedBytes += chunk.byteLength;
                  currentChunk++;
                  controller.enqueue(chunk);
                  controller.close();
                  return;
                }
              } catch (err) {
                if (options?.signal?.aborted) {
                  controller.error(new Error("Download aborted"));
                  return;
                }
                retryCount++;
                if (retryCount > maxRetries) {
                  controller.error(
                    new Error(
                      `Failed to download chunk after ${maxRetries} retries`
                    )
                  );
                  return;
                }
                const delay = retryDelayMs * Math.pow(2, retryCount - 1);
                await new Promise((resolve) => setTimeout(resolve, delay));
              }
            }
            if (chunk) {
              downloadedBytes += chunk.byteLength;
              currentChunk++;
              if (options?.onProgress) {
                const now = Date.now();
                const elapsed = (now - lastProgressTime) / 1e3;
                const bytesPerSecond = elapsed > 0 ? (downloadedBytes - lastProgressBytes) / elapsed : 0;
                lastProgressTime = now;
                lastProgressBytes = downloadedBytes;
                options.onProgress({
                  loaded: downloadedBytes,
                  total: totalSize,
                  percentage: totalSize ? Math.round(downloadedBytes / totalSize * 100) : null,
                  currentChunk,
                  totalChunks,
                  bytesPerSecond
                });
              }
              controller.enqueue(chunk);
              if (totalSize !== null && downloadedBytes >= totalSize) {
                controller.close();
              }
            }
          }
        });
        return {
          data: { stream, size: totalSize },
          error: null
        };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List files in the bucket
     * Supports both Supabase-style list(path, options) and Fluxbase-style list(options)
     * @param pathOrOptions - The folder path or list options
     * @param maybeOptions - List options when first param is a path
     */
    async list(pathOrOptions, maybeOptions) {
      try {
        const params = new URLSearchParams();
        let prefix;
        let options;
        if (typeof pathOrOptions === "string") {
          prefix = pathOrOptions;
          options = maybeOptions;
        } else {
          options = pathOrOptions;
          prefix = options?.prefix;
        }
        if (prefix) {
          params.set("prefix", prefix);
        }
        if (options?.limit) {
          params.set("limit", String(options.limit));
        }
        if (options?.offset) {
          params.set("offset", String(options.offset));
        }
        const queryString = params.toString();
        const path = `/api/v1/storage/${this.bucketName}${queryString ? `?${queryString}` : ""}`;
        const response = await this.fetch.get(path);
        const files = (response.files || []).map((file) => ({
          name: file.key || file.name,
          id: file.id,
          bucket_id: file.bucket || this.bucketName,
          created_at: file.last_modified || file.created_at,
          updated_at: file.updated_at,
          last_accessed_at: file.last_accessed_at,
          metadata: file.metadata
        }));
        return { data: files, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Remove files from the bucket
     * @param paths - Array of file paths to remove
     */
    async remove(paths) {
      try {
        const removedFiles = [];
        for (const path of paths) {
          await this.fetch.delete(`/api/v1/storage/${this.bucketName}/${path}`);
          removedFiles.push({
            name: path,
            bucket_id: this.bucketName
          });
        }
        return { data: removedFiles, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get a public URL for a file
     * @param path - The file path
     */
    getPublicUrl(path) {
      const publicUrl = `${this.fetch["baseUrl"]}/api/v1/storage/${this.bucketName}/${path}`;
      return { data: { publicUrl } };
    }
    /**
     * Create a signed URL for temporary access to a file
     * @param path - The file path
     * @param options - Signed URL options
     */
    async createSignedUrl(path, options) {
      try {
        const expiresIn = options?.expiresIn || 3600;
        const data = await this.fetch.post(
          `/api/v1/storage/${this.bucketName}/sign/${path}`,
          { expires_in: expiresIn }
        );
        return { data: { signedUrl: data.signed_url }, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Move a file to a new location
     * @param fromPath - Current file path
     * @param toPath - New file path
     */
    async move(fromPath, toPath) {
      try {
        await this.fetch.post(
          `/api/v1/storage/${this.bucketName}/move`,
          {
            from_path: fromPath,
            to_path: toPath
          }
        );
        return {
          data: { message: "Successfully moved" },
          error: null
        };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Copy a file to a new location
     * @param fromPath - Source file path
     * @param toPath - Destination file path
     */
    async copy(fromPath, toPath) {
      try {
        await this.fetch.post(
          `/api/v1/storage/${this.bucketName}/copy`,
          {
            from_path: fromPath,
            to_path: toPath
          }
        );
        return {
          data: { path: toPath },
          error: null
        };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Share a file with another user (RLS)
     * @param path - The file path
     * @param options - Share options (userId and permission)
     */
    async share(path, options) {
      try {
        await this.fetch.post(
          `/api/v1/storage/${this.bucketName}/${path}/share`,
          {
            user_id: options.userId,
            permission: options.permission
          }
        );
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Revoke file access from a user (RLS)
     * @param path - The file path
     * @param userId - The user ID to revoke access from
     */
    async revokeShare(path, userId) {
      try {
        await this.fetch.delete(
          `/api/v1/storage/${this.bucketName}/${path}/share/${userId}`
        );
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List users a file is shared with (RLS)
     * @param path - The file path
     */
    async listShares(path) {
      try {
        const data = await this.fetch.get(
          `/api/v1/storage/${this.bucketName}/${path}/shares`
        );
        return { data: data.shares || [], error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
  };
  var FluxbaseStorage = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Get a reference to a storage bucket
     * @param bucketName - The name of the bucket
     */
    from(bucketName) {
      return new StorageBucket(this.fetch, bucketName);
    }
    /**
     * List all buckets
     */
    async listBuckets() {
      try {
        const data = await this.fetch.get("/api/v1/storage/buckets");
        return { data: data.buckets || [], error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Create a new bucket
     * @param bucketName - The name of the bucket to create
     */
    async createBucket(bucketName) {
      try {
        await this.fetch.post(`/api/v1/storage/buckets/${bucketName}`);
        return { data: { name: bucketName }, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Delete a bucket
     * @param bucketName - The name of the bucket to delete
     */
    async deleteBucket(bucketName) {
      try {
        await this.fetch.delete(`/api/v1/storage/buckets/${bucketName}`);
        return { data: { message: "Successfully deleted" }, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Empty a bucket (delete all files)
     * @param bucketName - The name of the bucket to empty
     */
    async emptyBucket(bucketName) {
      try {
        const bucket = this.from(bucketName);
        const { data: objects, error: listError } = await bucket.list();
        if (listError) {
          return { data: null, error: listError };
        }
        if (objects && objects.length > 0) {
          const paths = objects.map((obj) => obj.name);
          const { error: removeError } = await bucket.remove(paths);
          if (removeError) {
            return { data: null, error: removeError };
          }
        }
        return { data: { message: "Successfully emptied" }, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Update bucket settings (RLS - requires admin or service key)
     * @param bucketName - The name of the bucket
     * @param settings - Bucket settings to update
     */
    async updateBucketSettings(bucketName, settings) {
      try {
        await this.fetch.put(`/api/v1/storage/buckets/${bucketName}`, settings);
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get bucket details
     * @param bucketName - The name of the bucket
     */
    async getBucket(bucketName) {
      try {
        const data = await this.fetch.get(
          `/api/v1/storage/buckets/${bucketName}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
  };

  // src/functions.ts
  var FluxbaseFunctions = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Invoke an edge function
     *
     * This method is fully compatible with Supabase's functions.invoke() API.
     *
     * @param functionName - The name of the function to invoke
     * @param options - Invocation options including body, headers, HTTP method, and namespace
     * @returns Promise resolving to { data, error } tuple
     *
     * @example
     * ```typescript
     * // Simple invocation (uses first matching function by namespace alphabetically)
     * const { data, error } = await client.functions.invoke('hello', {
     *   body: { name: 'World' }
     * })
     *
     * // Invoke a specific namespace's function
     * const { data, error } = await client.functions.invoke('hello', {
     *   body: { name: 'World' },
     *   namespace: 'my-app'
     * })
     *
     * // With GET method
     * const { data, error } = await client.functions.invoke('get-data', {
     *   method: 'GET'
     * })
     *
     * // With custom headers
     * const { data, error } = await client.functions.invoke('api-proxy', {
     *   body: { query: 'search' },
     *   headers: { 'Authorization': 'Bearer token' },
     *   method: 'POST'
     * })
     * ```
     */
    async invoke(functionName, options) {
      try {
        const method = options?.method || "POST";
        const headers = options?.headers || {};
        const body = options?.body;
        const namespace = options?.namespace;
        const endpoint = namespace ? `/api/v1/functions/${functionName}/invoke?namespace=${encodeURIComponent(namespace)}` : `/api/v1/functions/${functionName}/invoke`;
        let response;
        switch (method) {
          case "GET":
            response = await this.fetch.get(endpoint, { headers });
            break;
          case "DELETE":
            response = await this.fetch.delete(endpoint, { headers });
            break;
          case "PUT":
            response = await this.fetch.put(endpoint, body, { headers });
            break;
          case "PATCH":
            response = await this.fetch.patch(endpoint, body, { headers });
            break;
          case "POST":
          default:
            response = await this.fetch.post(endpoint, body, { headers });
            break;
        }
        return { data: response, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List all public edge functions
     *
     * @returns Promise resolving to { data, error } tuple with array of public functions
     *
     * @example
     * ```typescript
     * const { data, error } = await client.functions.list()
     * if (data) {
     *   console.log('Functions:', data.map(f => f.name))
     * }
     * ```
     */
    async list() {
      try {
        const data = await this.fetch.get("/api/v1/functions");
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get details of a specific edge function
     *
     * @param name - Function name
     * @returns Promise resolving to { data, error } tuple with function metadata
     *
     * @example
     * ```typescript
     * const { data, error } = await client.functions.get('my-function')
     * if (data) {
     *   console.log('Function version:', data.version)
     * }
     * ```
     */
    async get(name) {
      try {
        const data = await this.fetch.get(`/api/v1/functions/${name}`);
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
  };

  // src/jobs.ts
  var FluxbaseJobs = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Submit a new job for execution
     *
     * @param jobName - Name of the job function to execute
     * @param payload - Job input data
     * @param options - Additional options (priority, namespace, scheduled time)
     * @returns Promise resolving to { data, error } tuple with submitted job details
     *
     * @example
     * ```typescript
     * // Submit a simple job
     * const { data, error } = await client.jobs.submit('send-email', {
     *   to: 'user@example.com',
     *   subject: 'Hello',
     *   body: 'Welcome!'
     * })
     *
     * if (data) {
     *   console.log('Job submitted:', data.id)
     *   console.log('Status:', data.status)
     * }
     *
     * // Submit with priority
     * const { data } = await client.jobs.submit('high-priority-task', payload, {
     *   priority: 10
     * })
     *
     * // Schedule for later
     * const { data } = await client.jobs.submit('scheduled-task', payload, {
     *   scheduled: '2025-01-01T00:00:00Z'
     * })
     * ```
     */
    async submit(jobName, payload, options) {
      try {
        const request = {
          job_name: jobName,
          payload,
          ...options
        };
        const data = await this.fetch.post("/api/v1/jobs/submit", request);
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get status and details of a specific job
     *
     * @param jobId - Job ID
     * @returns Promise resolving to { data, error } tuple with job details
     *
     * @example
     * ```typescript
     * const { data: job, error } = await client.jobs.get('550e8400-e29b-41d4-a716-446655440000')
     *
     * if (job) {
     *   console.log('Status:', job.status)
     *   console.log('Progress:', job.progress_percent + '%')
     *   console.log('Result:', job.result)
     *   console.log('Logs:', job.logs)
     * }
     * ```
     */
    async get(jobId) {
      try {
        const data = await this.fetch.get(`/api/v1/jobs/${jobId}`);
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List jobs submitted by the current user
     *
     * @param filters - Optional filters (status, namespace, limit, offset)
     * @returns Promise resolving to { data, error } tuple with array of jobs
     *
     * @example
     * ```typescript
     * // List all your jobs
     * const { data: jobs, error } = await client.jobs.list()
     *
     * // Filter by status
     * const { data: running } = await client.jobs.list({
     *   status: 'running'
     * })
     *
     * // Paginate
     * const { data: page } = await client.jobs.list({
     *   limit: 20,
     *   offset: 40
     * })
     * ```
     */
    async list(filters) {
      try {
        const params = new URLSearchParams();
        if (filters?.status) params.append("status", filters.status);
        if (filters?.namespace) params.append("namespace", filters.namespace);
        if (filters?.limit) params.append("limit", filters.limit.toString());
        if (filters?.offset) params.append("offset", filters.offset.toString());
        const queryString = params.toString();
        const data = await this.fetch.get(
          `/api/v1/jobs${queryString ? `?${queryString}` : ""}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Cancel a pending or running job
     *
     * @param jobId - Job ID to cancel
     * @returns Promise resolving to { data, error } tuple
     *
     * @example
     * ```typescript
     * const { error } = await client.jobs.cancel('550e8400-e29b-41d4-a716-446655440000')
     *
     * if (!error) {
     *   console.log('Job cancelled successfully')
     * }
     * ```
     */
    async cancel(jobId) {
      try {
        await this.fetch.post(`/api/v1/jobs/${jobId}/cancel`, {});
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Retry a failed job
     *
     * Creates a new job execution with the same parameters
     *
     * @param jobId - Job ID to retry
     * @returns Promise resolving to { data, error } tuple with new job
     *
     * @example
     * ```typescript
     * const { data: newJob, error } = await client.jobs.retry('550e8400-e29b-41d4-a716-446655440000')
     *
     * if (newJob) {
     *   console.log('Job retried, new ID:', newJob.id)
     * }
     * ```
     */
    async retry(jobId) {
      try {
        const data = await this.fetch.post(`/api/v1/jobs/${jobId}/retry`, {});
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
  };

  // src/settings.ts
  var SystemSettingsManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * List all system settings
     *
     * @returns Promise resolving to ListSystemSettingsResponse
     *
     * @example
     * ```typescript
     * const response = await client.admin.settings.system.list()
     * console.log(response.settings)
     * ```
     */
    async list() {
      const settings = await this.fetch.get(
        "/api/v1/admin/system/settings"
      );
      return { settings: Array.isArray(settings) ? settings : [] };
    }
    /**
     * Get a specific system setting by key
     *
     * @param key - Setting key (e.g., 'app.auth.enable_signup')
     * @returns Promise resolving to SystemSetting
     *
     * @example
     * ```typescript
     * const setting = await client.admin.settings.system.get('app.auth.enable_signup')
     * console.log(setting.value)
     * ```
     */
    async get(key) {
      return await this.fetch.get(
        `/api/v1/admin/system/settings/${key}`
      );
    }
    /**
     * Update or create a system setting
     *
     * @param key - Setting key
     * @param request - Update request with value and optional description
     * @returns Promise resolving to SystemSetting
     *
     * @example
     * ```typescript
     * const updated = await client.admin.settings.system.update('app.auth.enable_signup', {
     *   value: { value: true },
     *   description: 'Enable user signup'
     * })
     * ```
     */
    async update(key, request) {
      return await this.fetch.put(
        `/api/v1/admin/system/settings/${key}`,
        request
      );
    }
    /**
     * Delete a system setting
     *
     * @param key - Setting key to delete
     * @returns Promise<void>
     *
     * @example
     * ```typescript
     * await client.admin.settings.system.delete('app.auth.enable_signup')
     * ```
     */
    async delete(key) {
      await this.fetch.delete(`/api/v1/admin/system/settings/${key}`);
    }
  };
  var AppSettingsManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Get all application settings
     *
     * Returns structured settings for authentication, features, email, and security.
     *
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * const settings = await client.admin.settings.app.get()
     *
     * console.log('Signup enabled:', settings.authentication.enable_signup)
     * console.log('Realtime enabled:', settings.features.enable_realtime)
     * console.log('Email provider:', settings.email.provider)
     * ```
     */
    async get() {
      return await this.fetch.get("/api/v1/admin/app/settings");
    }
    /**
     * Update application settings
     *
     * Supports partial updates - only provide the fields you want to change.
     *
     * @param request - Settings to update (partial update supported)
     * @returns Promise resolving to AppSettings - Updated settings
     *
     * @example
     * ```typescript
     * // Update authentication settings
     * const updated = await client.admin.settings.app.update({
     *   authentication: {
     *     enable_signup: true,
     *     password_min_length: 12
     *   }
     * })
     *
     * // Update multiple categories
     * await client.admin.settings.app.update({
     *   authentication: { enable_signup: false },
     *   features: { enable_realtime: true },
     *   security: { enable_global_rate_limit: true }
     * })
     * ```
     */
    async update(request) {
      return await this.fetch.put(
        "/api/v1/admin/app/settings",
        request
      );
    }
    /**
     * Reset all application settings to defaults
     *
     * This will delete all custom settings and return to default values.
     *
     * @returns Promise resolving to AppSettings - Default settings
     *
     * @example
     * ```typescript
     * const defaults = await client.admin.settings.app.reset()
     * console.log('Settings reset to defaults:', defaults)
     * ```
     */
    async reset() {
      return await this.fetch.post(
        "/api/v1/admin/app/settings/reset",
        {}
      );
    }
    /**
     * Enable user signup
     *
     * Convenience method to enable user registration.
     *
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.enableSignup()
     * ```
     */
    async enableSignup() {
      return await this.update({
        authentication: { enable_signup: true }
      });
    }
    /**
     * Disable user signup
     *
     * Convenience method to disable user registration.
     *
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.disableSignup()
     * ```
     */
    async disableSignup() {
      return await this.update({
        authentication: { enable_signup: false }
      });
    }
    /**
     * Update password minimum length
     *
     * Convenience method to set password requirements.
     *
     * @param length - Minimum password length (8-128 characters)
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.setPasswordMinLength(12)
     * ```
     */
    async setPasswordMinLength(length) {
      if (length < 8 || length > 128) {
        throw new Error(
          "Password minimum length must be between 8 and 128 characters"
        );
      }
      return await this.update({
        authentication: { password_min_length: length }
      });
    }
    /**
     * Enable or disable a feature
     *
     * Convenience method to toggle feature flags.
     *
     * @param feature - Feature name ('realtime' | 'storage' | 'functions')
     * @param enabled - Whether to enable or disable the feature
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * // Enable realtime
     * await client.admin.settings.app.setFeature('realtime', true)
     *
     * // Disable storage
     * await client.admin.settings.app.setFeature('storage', false)
     * ```
     */
    async setFeature(feature, enabled) {
      const featureKey = feature === "realtime" ? "enable_realtime" : feature === "storage" ? "enable_storage" : "enable_functions";
      return await this.update({
        features: { [featureKey]: enabled }
      });
    }
    /**
     * Enable or disable global rate limiting
     *
     * Convenience method to toggle global rate limiting.
     *
     * @param enabled - Whether to enable rate limiting
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.setRateLimiting(true)
     * ```
     */
    async setRateLimiting(enabled) {
      return await this.update({
        security: { enable_global_rate_limit: enabled }
      });
    }
    /**
     * Configure SMTP email provider
     *
     * Convenience method to set up SMTP email delivery.
     *
     * @param config - SMTP configuration
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.configureSMTP({
     *   host: 'smtp.gmail.com',
     *   port: 587,
     *   username: 'your-email@gmail.com',
     *   password: 'your-app-password',
     *   use_tls: true,
     *   from_address: 'noreply@yourapp.com',
     *   from_name: 'Your App'
     * })
     * ```
     */
    async configureSMTP(config) {
      return await this.update({
        email: {
          enabled: true,
          provider: "smtp",
          from_address: config.from_address,
          from_name: config.from_name,
          reply_to_address: config.reply_to_address,
          smtp: {
            host: config.host,
            port: config.port,
            username: config.username,
            password: config.password,
            use_tls: config.use_tls
          }
        }
      });
    }
    /**
     * Configure SendGrid email provider
     *
     * Convenience method to set up SendGrid email delivery.
     *
     * @param apiKey - SendGrid API key
     * @param options - Optional from address, name, and reply-to
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.configureSendGrid('SG.xxx', {
     *   from_address: 'noreply@yourapp.com',
     *   from_name: 'Your App'
     * })
     * ```
     */
    async configureSendGrid(apiKey, options) {
      return await this.update({
        email: {
          enabled: true,
          provider: "sendgrid",
          from_address: options?.from_address,
          from_name: options?.from_name,
          reply_to_address: options?.reply_to_address,
          sendgrid: {
            api_key: apiKey
          }
        }
      });
    }
    /**
     * Configure Mailgun email provider
     *
     * Convenience method to set up Mailgun email delivery.
     *
     * @param apiKey - Mailgun API key
     * @param domain - Mailgun domain
     * @param options - Optional EU region flag and email addresses
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.configureMailgun('key-xxx', 'mg.yourapp.com', {
     *   eu_region: false,
     *   from_address: 'noreply@yourapp.com',
     *   from_name: 'Your App'
     * })
     * ```
     */
    async configureMailgun(apiKey, domain, options) {
      return await this.update({
        email: {
          enabled: true,
          provider: "mailgun",
          from_address: options?.from_address,
          from_name: options?.from_name,
          reply_to_address: options?.reply_to_address,
          mailgun: {
            api_key: apiKey,
            domain,
            eu_region: options?.eu_region ?? false
          }
        }
      });
    }
    /**
     * Configure AWS SES email provider
     *
     * Convenience method to set up AWS SES email delivery.
     *
     * @param accessKeyId - AWS access key ID
     * @param secretAccessKey - AWS secret access key
     * @param region - AWS region (e.g., 'us-east-1')
     * @param options - Optional email addresses
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.configureSES(
     *   'AKIAIOSFODNN7EXAMPLE',
     *   'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',
     *   'us-east-1',
     *   {
     *     from_address: 'noreply@yourapp.com',
     *     from_name: 'Your App'
     *   }
     * )
     * ```
     */
    async configureSES(accessKeyId, secretAccessKey, region, options) {
      return await this.update({
        email: {
          enabled: true,
          provider: "ses",
          from_address: options?.from_address,
          from_name: options?.from_name,
          reply_to_address: options?.reply_to_address,
          ses: {
            access_key_id: accessKeyId,
            secret_access_key: secretAccessKey,
            region
          }
        }
      });
    }
    /**
     * Enable or disable email functionality
     *
     * Convenience method to toggle email system on/off.
     *
     * @param enabled - Whether to enable email
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.setEmailEnabled(true)
     * ```
     */
    async setEmailEnabled(enabled) {
      return await this.update({
        email: { enabled }
      });
    }
    /**
     * Configure password complexity requirements
     *
     * Convenience method to set password validation rules.
     *
     * @param requirements - Password complexity requirements
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.setPasswordComplexity({
     *   min_length: 12,
     *   require_uppercase: true,
     *   require_lowercase: true,
     *   require_number: true,
     *   require_special: true
     * })
     * ```
     */
    async setPasswordComplexity(requirements) {
      return await this.update({
        authentication: {
          password_min_length: requirements.min_length,
          password_require_uppercase: requirements.require_uppercase,
          password_require_lowercase: requirements.require_lowercase,
          password_require_number: requirements.require_number,
          password_require_special: requirements.require_special
        }
      });
    }
    /**
     * Configure session settings
     *
     * Convenience method to set session timeout and limits.
     *
     * @param timeoutMinutes - Session timeout in minutes (0 for no timeout)
     * @param maxSessionsPerUser - Maximum concurrent sessions per user (0 for unlimited)
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * // 30 minute sessions, max 3 devices per user
     * await client.admin.settings.app.setSessionSettings(30, 3)
     * ```
     */
    async setSessionSettings(timeoutMinutes, maxSessionsPerUser) {
      return await this.update({
        authentication: {
          session_timeout_minutes: timeoutMinutes,
          max_sessions_per_user: maxSessionsPerUser
        }
      });
    }
    /**
     * Enable or disable email verification requirement
     *
     * Convenience method to require email verification for new signups.
     *
     * @param required - Whether to require email verification
     * @returns Promise resolving to AppSettings
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.setEmailVerificationRequired(true)
     * ```
     */
    async setEmailVerificationRequired(required) {
      return await this.update({
        authentication: { require_email_verification: required }
      });
    }
    // ===================================================================
    // CUSTOM SETTINGS METHODS
    // Flexible key-value storage for application-specific configuration
    // ===================================================================
    /**
     * Get a specific custom setting's value only (without metadata)
     *
     * Convenience method that returns just the value field instead of the full CustomSetting object.
     *
     * @param key - Setting key (e.g., 'billing.tiers', 'features.beta_enabled')
     * @returns Promise resolving to the setting's value
     *
     * @example
     * ```typescript
     * const tiers = await client.admin.settings.app.getSetting('billing.tiers')
     * console.log(tiers) // { free: 1000, pro: 10000, enterprise: 100000 }
     * ```
     */
    async getSetting(key) {
      const setting = await this.fetch.get(
        `/api/v1/admin/settings/custom/${key}`
      );
      return setting.value;
    }
    /**
     * Get multiple custom settings' values by keys
     *
     * Fetches multiple settings in a single request and returns only their values.
     *
     * @param keys - Array of setting keys to fetch
     * @returns Promise resolving to object mapping keys to values
     *
     * @example
     * ```typescript
     * const values = await client.admin.settings.app.getSettings([
     *   'billing.tiers',
     *   'features.beta_enabled'
     * ])
     * console.log(values)
     * // {
     * //   'billing.tiers': { free: 1000, pro: 10000 },
     * //   'features.beta_enabled': { enabled: true }
     * // }
     * ```
     */
    async getSettings(keys) {
      const response = await this.fetch.post(
        "/api/v1/settings/batch",
        { keys }
      );
      return response.reduce(
        (acc, setting) => {
          acc[setting.key] = setting.value;
          return acc;
        },
        {}
      );
    }
    /**
     * Set or create a custom setting
     *
     * Creates a new custom setting or updates an existing one.
     *
     * @param key - Setting key
     * @param value - Setting value (any JSON-serializable value)
     * @param options - Optional configuration (description, is_public, is_secret, etc.)
     * @returns Promise resolving to CustomSetting
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.setSetting('billing.tiers', {
     *   free: 1000,
     *   pro: 10000,
     *   enterprise: 100000
     * }, {
     *   description: 'API quotas per billing tier',
     *   is_public: false
     * })
     * ```
     */
    async setSetting(key, value, options) {
      try {
        return await this.fetch.put(
          `/api/v1/admin/settings/custom/${key}`,
          {
            value,
            description: options?.description,
            is_public: options?.is_public,
            is_secret: options?.is_secret
          }
        );
      } catch (error) {
        if (error.status === 404 || error.message?.includes("not found")) {
          return await this.fetch.post(
            "/api/v1/admin/settings/custom",
            {
              key,
              value,
              value_type: options?.value_type || "json",
              description: options?.description,
              is_public: options?.is_public ?? false,
              is_secret: options?.is_secret ?? false
            }
          );
        }
        throw error;
      }
    }
    /**
     * List all custom settings
     *
     * @returns Promise resolving to array of CustomSetting objects
     *
     * @example
     * ```typescript
     * const settings = await client.admin.settings.app.listSettings()
     * settings.forEach(s => console.log(s.key, s.value))
     * ```
     */
    async listSettings() {
      return await this.fetch.get(
        "/api/v1/admin/settings/custom"
      );
    }
    /**
     * Delete a custom setting
     *
     * @param key - Setting key to delete
     * @returns Promise<void>
     *
     * @example
     * ```typescript
     * await client.admin.settings.app.deleteSetting('billing.tiers')
     * ```
     */
    async deleteSetting(key) {
      await this.fetch.delete(`/api/v1/admin/settings/custom/${key}`);
    }
  };
  var EmailTemplateManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * List all email templates
     *
     * @returns Promise resolving to ListEmailTemplatesResponse
     *
     * @example
     * ```typescript
     * const response = await client.admin.emailTemplates.list()
     * console.log(response.templates)
     * ```
     */
    async list() {
      const templates = await this.fetch.get(
        "/api/v1/admin/email/templates"
      );
      return { templates: Array.isArray(templates) ? templates : [] };
    }
    /**
     * Get a specific email template by type
     *
     * @param type - Template type (magic_link | verify_email | reset_password | invite_user)
     * @returns Promise resolving to EmailTemplate
     *
     * @example
     * ```typescript
     * const template = await client.admin.emailTemplates.get('magic_link')
     * console.log(template.subject)
     * console.log(template.html_body)
     * ```
     */
    async get(type) {
      return await this.fetch.get(
        `/api/v1/admin/email/templates/${type}`
      );
    }
    /**
     * Update an email template
     *
     * Available template variables:
     * - magic_link: `{{.MagicLink}}`, `{{.AppName}}`, `{{.ExpiryMinutes}}`
     * - verify_email: `{{.VerificationLink}}`, `{{.AppName}}`
     * - reset_password: `{{.ResetLink}}`, `{{.AppName}}`, `{{.ExpiryMinutes}}`
     * - invite_user: `{{.InviteLink}}`, `{{.AppName}}`, `{{.InviterName}}`
     *
     * @param type - Template type to update
     * @param request - Update request with subject, html_body, and optional text_body
     * @returns Promise resolving to EmailTemplate
     *
     * @example
     * ```typescript
     * const updated = await client.admin.emailTemplates.update('magic_link', {
     *   subject: 'Your Magic Link - Sign in to ' + '{{.AppName}}',
     *   html_body: '<html><body><h1>Welcome!</h1><a href="' + '{{.MagicLink}}' + '">Sign In</a></body></html>',
     *   text_body: 'Click here to sign in: ' + '{{.MagicLink}}'
     * })
     * ```
     */
    async update(type, request) {
      return await this.fetch.put(
        `/api/v1/admin/email/templates/${type}`,
        request
      );
    }
    /**
     * Reset an email template to default
     *
     * Removes any customizations and restores the template to its original state.
     *
     * @param type - Template type to reset
     * @returns Promise resolving to EmailTemplate - The default template
     *
     * @example
     * ```typescript
     * const defaultTemplate = await client.admin.emailTemplates.reset('magic_link')
     * ```
     */
    async reset(type) {
      return await this.fetch.post(
        `/api/v1/admin/email/templates/${type}/reset`,
        {}
      );
    }
    /**
     * Send a test email using the template
     *
     * Useful for previewing template changes before deploying to production.
     *
     * @param type - Template type to test
     * @param recipientEmail - Email address to send test to
     * @returns Promise<void>
     *
     * @example
     * ```typescript
     * await client.admin.emailTemplates.test('magic_link', 'test@example.com')
     * ```
     */
    async test(type, recipientEmail) {
      await this.fetch.post(`/api/v1/admin/email/templates/${type}/test`, {
        recipient_email: recipientEmail
      });
    }
  };
  var FluxbaseSettings = class {
    constructor(fetch2) {
      this.system = new SystemSettingsManager(fetch2);
      this.app = new AppSettingsManager(fetch2);
    }
  };
  var SettingsClient = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Get a single setting's value
     *
     * Returns only the value field of the setting.
     * Access is controlled by RLS policies - will return 403 if the user
     * doesn't have permission to read the setting.
     *
     * @param key - Setting key (e.g., 'features.beta_enabled')
     * @returns Promise resolving to the setting's value
     * @throws Error if setting doesn't exist or user lacks permission
     *
     * @example
     * ```typescript
     * // Get public setting (any user)
     * const value = await client.settings.get('features.beta_enabled')
     * console.log(value) // { enabled: true }
     *
     * // Get restricted setting (requires permission)
     * try {
     *   const secret = await client.settings.get('internal.api_key')
     * } catch (error) {
     *   console.error('Access denied:', error)
     * }
     * ```
     */
    async get(key) {
      const response = await this.fetch.get(
        `/api/v1/settings/${encodeURIComponent(key)}`
      );
      return response.value;
    }
    /**
     * Get multiple settings' values by keys
     *
     * Fetches multiple settings in a single request.
     * Only returns settings the user has permission to read based on RLS policies.
     * Settings the user can't access will be omitted from the result (no error thrown).
     *
     * @param keys - Array of setting keys to fetch
     * @returns Promise resolving to object mapping keys to values
     *
     * @example
     * ```typescript
     * const values = await client.settings.getMany([
     *   'features.beta_enabled',  // public - will be returned
     *   'features.dark_mode',      // public - will be returned
     *   'internal.api_key'         // secret - will be omitted
     * ])
     * console.log(values)
     * // {
     * //   'features.beta_enabled': { enabled: true },
     * //   'features.dark_mode': { enabled: false }
     * //   // 'internal.api_key' is omitted (no error)
     * // }
     * ```
     */
    async getMany(keys) {
      const response = await this.fetch.post(
        "/api/v1/settings/batch",
        { keys }
      );
      return response.reduce(
        (acc, setting) => {
          acc[setting.key] = setting.value;
          return acc;
        },
        {}
      );
    }
  };

  // src/ddl.ts
  var DDLManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Create a new database schema
     *
     * Creates a new schema in the database. Schemas are used to organize tables
     * into logical groups and provide namespace isolation.
     *
     * @param name - Schema name (must be valid PostgreSQL identifier)
     * @returns Promise resolving to CreateSchemaResponse
     *
     * @example
     * ```typescript
     * // Create a schema for analytics data
     * const result = await client.admin.ddl.createSchema('analytics')
     * console.log(result.message) // "Schema created successfully"
     * console.log(result.schema)  // "analytics"
     * ```
     */
    async createSchema(name) {
      const request = { name };
      return await this.fetch.post("/api/v1/admin/ddl/schemas", request);
    }
    /**
     * List all database schemas
     *
     * Retrieves a list of all schemas in the database. This includes both
     * system schemas (like 'public', 'pg_catalog') and user-created schemas.
     *
     * @returns Promise resolving to ListSchemasResponse
     *
     * @example
     * ```typescript
     * const { schemas } = await client.admin.ddl.listSchemas()
     *
     * schemas.forEach(schema => {
     *   console.log(`Schema: ${schema.name}, Owner: ${schema.owner}`)
     * })
     * ```
     */
    async listSchemas() {
      return await this.fetch.get("/api/v1/admin/ddl/schemas");
    }
    /**
     * Create a new table in a schema
     *
     * Creates a new table with the specified columns. Supports various column
     * options including primary keys, nullability, data types, and default values.
     *
     * @param schema - Schema name where the table will be created
     * @param name - Table name (must be valid PostgreSQL identifier)
     * @param columns - Array of column definitions
     * @returns Promise resolving to CreateTableResponse
     *
     * @example
     * ```typescript
     * // Create a users table
     * await client.admin.ddl.createTable('public', 'users', [
     *   {
     *     name: 'id',
     *     type: 'UUID',
     *     primaryKey: true,
     *     defaultValue: 'gen_random_uuid()'
     *   },
     *   {
     *     name: 'email',
     *     type: 'TEXT',
     *     nullable: false
     *   },
     *   {
     *     name: 'name',
     *     type: 'TEXT'
     *   },
     *   {
     *     name: 'created_at',
     *     type: 'TIMESTAMPTZ',
     *     nullable: false,
     *     defaultValue: 'NOW()'
     *   }
     * ])
     * ```
     *
     * @example
     * ```typescript
     * // Create a products table with JSONB metadata
     * await client.admin.ddl.createTable('public', 'products', [
     *   { name: 'id', type: 'SERIAL', primaryKey: true },
     *   { name: 'name', type: 'TEXT', nullable: false },
     *   { name: 'price', type: 'DECIMAL(10,2)', nullable: false },
     *   { name: 'metadata', type: 'JSONB' },
     *   { name: 'in_stock', type: 'BOOLEAN', defaultValue: 'true' }
     * ])
     * ```
     */
    async createTable(schema, name, columns) {
      const request = { schema, name, columns };
      return await this.fetch.post("/api/v1/admin/ddl/tables", request);
    }
    /**
     * List all tables in the database or a specific schema
     *
     * Retrieves a list of all tables. If a schema is specified, only tables
     * from that schema are returned. Otherwise, all tables from all schemas
     * are returned.
     *
     * @param schema - Optional schema name to filter tables
     * @returns Promise resolving to ListTablesResponse
     *
     * @example
     * ```typescript
     * // List all tables in the public schema
     * const { tables } = await client.admin.ddl.listTables('public')
     *
     * tables.forEach(table => {
     *   console.log(`Table: ${table.schema}.${table.name}`)
     *   table.columns?.forEach(col => {
     *     console.log(`  - ${col.name}: ${col.type}`)
     *   })
     * })
     * ```
     *
     * @example
     * ```typescript
     * // List all tables across all schemas
     * const { tables } = await client.admin.ddl.listTables()
     *
     * const tablesBySchema = tables.reduce((acc, table) => {
     *   if (!acc[table.schema]) acc[table.schema] = []
     *   acc[table.schema].push(table.name)
     *   return acc
     * }, {} as Record<string, string[]>)
     *
     * console.log(tablesBySchema)
     * ```
     */
    async listTables(schema) {
      const params = schema ? `?schema=${encodeURIComponent(schema)}` : "";
      return await this.fetch.get(`/api/v1/admin/ddl/tables${params}`);
    }
    /**
     * Delete a table from a schema
     *
     * Permanently deletes a table and all its data. This operation cannot be undone.
     *
     * @param schema - Schema name containing the table
     * @param name - Table name to delete
     * @returns Promise resolving to DeleteTableResponse
     *
     * @example
     * ```typescript
     * // Delete a table
     * const result = await client.admin.ddl.deleteTable('public', 'old_data')
     * console.log(result.message) // "Table deleted successfully"
     * ```
     *
     * @example
     * ```typescript
     * // Safe deletion with confirmation
     * const confirm = await askUser('Are you sure you want to delete this table?')
     * if (confirm) {
     *   await client.admin.ddl.deleteTable('analytics', 'events')
     *   console.log('Table deleted')
     * }
     * ```
     */
    async deleteTable(schema, name) {
      return await this.fetch.delete(
        `/api/v1/admin/ddl/tables/${encodeURIComponent(schema)}/${encodeURIComponent(name)}`
      );
    }
  };

  // src/oauth.ts
  var OAuthProviderManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * List all OAuth providers
     *
     * Retrieves all configured OAuth providers including both enabled and disabled providers.
     * Note: Client secrets are not included in the response for security reasons.
     *
     * @returns Promise resolving to ListOAuthProvidersResponse
     *
     * @example
     * ```typescript
     * const { providers } = await client.admin.oauth.listProviders()
     *
     * providers.forEach(provider => {
     *   console.log(`${provider.display_name}: ${provider.enabled ? 'enabled' : 'disabled'}`)
     * })
     * ```
     */
    async listProviders() {
      const providers = await this.fetch.get("/api/v1/admin/oauth/providers");
      return Array.isArray(providers) ? providers : [];
    }
    /**
     * Get a specific OAuth provider by ID
     *
     * Retrieves detailed configuration for a single OAuth provider.
     * Note: Client secret is not included in the response.
     *
     * @param providerId - Provider ID (UUID)
     * @returns Promise resolving to OAuthProvider
     *
     * @example
     * ```typescript
     * const provider = await client.admin.oauth.getProvider('provider-uuid')
     *
     * console.log('Provider:', provider.display_name)
     * console.log('Scopes:', provider.scopes.join(', '))
     * console.log('Redirect URL:', provider.redirect_url)
     * ```
     */
    async getProvider(providerId) {
      return await this.fetch.get(`/api/v1/admin/oauth/providers/${providerId}`);
    }
    /**
     * Create a new OAuth provider
     *
     * Creates a new OAuth provider configuration. For built-in providers (Google, GitHub, etc.),
     * set `is_custom` to false. For custom OAuth2 providers, set `is_custom` to true and provide
     * the authorization, token, and user info URLs.
     *
     * @param request - OAuth provider configuration
     * @returns Promise resolving to CreateOAuthProviderResponse
     *
     * @example
     * ```typescript
     * // Create GitHub provider
     * const result = await client.admin.oauth.createProvider({
     *   provider_name: 'github',
     *   display_name: 'GitHub',
     *   enabled: true,
     *   client_id: process.env.GITHUB_CLIENT_ID,
     *   client_secret: process.env.GITHUB_CLIENT_SECRET,
     *   redirect_url: 'https://yourapp.com/auth/callback',
     *   scopes: ['user:email', 'read:user'],
     *   is_custom: false
     * })
     *
     * console.log('Provider created:', result.id)
     * ```
     *
     * @example
     * ```typescript
     * // Create custom OAuth2 provider
     * await client.admin.oauth.createProvider({
     *   provider_name: 'custom_sso',
     *   display_name: 'Custom SSO',
     *   enabled: true,
     *   client_id: 'client-id',
     *   client_secret: 'client-secret',
     *   redirect_url: 'https://yourapp.com/auth/callback',
     *   scopes: ['openid', 'profile', 'email'],
     *   is_custom: true,
     *   authorization_url: 'https://sso.example.com/oauth/authorize',
     *   token_url: 'https://sso.example.com/oauth/token',
     *   user_info_url: 'https://sso.example.com/oauth/userinfo'
     * })
     * ```
     */
    async createProvider(request) {
      return await this.fetch.post("/api/v1/admin/oauth/providers", request);
    }
    /**
     * Update an existing OAuth provider
     *
     * Updates an OAuth provider configuration. All fields are optional - only provided fields
     * will be updated. To update the client secret, provide a non-empty value.
     *
     * @param providerId - Provider ID (UUID)
     * @param request - Fields to update
     * @returns Promise resolving to UpdateOAuthProviderResponse
     *
     * @example
     * ```typescript
     * // Disable a provider
     * await client.admin.oauth.updateProvider('provider-id', {
     *   enabled: false
     * })
     * ```
     *
     * @example
     * ```typescript
     * // Update scopes and redirect URL
     * await client.admin.oauth.updateProvider('provider-id', {
     *   scopes: ['user:email', 'read:user', 'read:org'],
     *   redirect_url: 'https://newdomain.com/auth/callback'
     * })
     * ```
     *
     * @example
     * ```typescript
     * // Rotate client secret
     * await client.admin.oauth.updateProvider('provider-id', {
     *   client_id: 'new-client-id',
     *   client_secret: 'new-client-secret'
     * })
     * ```
     */
    async updateProvider(providerId, request) {
      return await this.fetch.put(
        `/api/v1/admin/oauth/providers/${providerId}`,
        request
      );
    }
    /**
     * Delete an OAuth provider
     *
     * Permanently deletes an OAuth provider configuration. This will prevent users from
     * authenticating with this provider.
     *
     * @param providerId - Provider ID (UUID) to delete
     * @returns Promise resolving to DeleteOAuthProviderResponse
     *
     * @example
     * ```typescript
     * await client.admin.oauth.deleteProvider('provider-id')
     * console.log('Provider deleted')
     * ```
     *
     * @example
     * ```typescript
     * // Safe deletion with confirmation
     * const provider = await client.admin.oauth.getProvider('provider-id')
     * const confirmed = await confirm(`Delete ${provider.display_name}?`)
     *
     * if (confirmed) {
     *   await client.admin.oauth.deleteProvider('provider-id')
     * }
     * ```
     */
    async deleteProvider(providerId) {
      return await this.fetch.delete(
        `/api/v1/admin/oauth/providers/${providerId}`
      );
    }
    /**
     * Enable an OAuth provider
     *
     * Convenience method to enable a provider.
     *
     * @param providerId - Provider ID (UUID)
     * @returns Promise resolving to UpdateOAuthProviderResponse
     *
     * @example
     * ```typescript
     * await client.admin.oauth.enableProvider('provider-id')
     * ```
     */
    async enableProvider(providerId) {
      return await this.updateProvider(providerId, { enabled: true });
    }
    /**
     * Disable an OAuth provider
     *
     * Convenience method to disable a provider.
     *
     * @param providerId - Provider ID (UUID)
     * @returns Promise resolving to UpdateOAuthProviderResponse
     *
     * @example
     * ```typescript
     * await client.admin.oauth.disableProvider('provider-id')
     * ```
     */
    async disableProvider(providerId) {
      return await this.updateProvider(providerId, { enabled: false });
    }
  };
  var AuthSettingsManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Get current authentication settings
     *
     * Retrieves all authentication configuration settings.
     *
     * @returns Promise resolving to AuthSettings
     *
     * @example
     * ```typescript
     * const settings = await client.admin.authSettings.get()
     *
     * console.log('Password min length:', settings.password_min_length)
     * console.log('Signup enabled:', settings.enable_signup)
     * console.log('Session timeout:', settings.session_timeout_minutes, 'minutes')
     * ```
     */
    async get() {
      return await this.fetch.get("/api/v1/admin/auth/settings");
    }
    /**
     * Update authentication settings
     *
     * Updates one or more authentication settings. All fields are optional - only provided
     * fields will be updated.
     *
     * @param request - Settings to update
     * @returns Promise resolving to UpdateAuthSettingsResponse
     *
     * @example
     * ```typescript
     * // Strengthen password requirements
     * await client.admin.authSettings.update({
     *   password_min_length: 16,
     *   password_require_uppercase: true,
     *   password_require_lowercase: true,
     *   password_require_number: true,
     *   password_require_special: true
     * })
     * ```
     *
     * @example
     * ```typescript
     * // Extend session timeout
     * await client.admin.authSettings.update({
     *   session_timeout_minutes: 240,
     *   max_sessions_per_user: 10
     * })
     * ```
     *
     * @example
     * ```typescript
     * // Disable email verification during development
     * await client.admin.authSettings.update({
     *   require_email_verification: false
     * })
     * ```
     */
    async update(request) {
      return await this.fetch.put("/api/v1/admin/auth/settings", request);
    }
  };
  var FluxbaseOAuth = class {
    constructor(fetch2) {
      this.providers = new OAuthProviderManager(fetch2);
      this.authSettings = new AuthSettingsManager(fetch2);
    }
  };

  // src/impersonation.ts
  var ImpersonationManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Impersonate a specific user
     *
     * Start an impersonation session as a specific user. This allows you to see data
     * exactly as that user would see it, respecting all RLS policies and permissions.
     *
     * @param request - Impersonation request with target user ID and reason
     * @returns Promise resolving to impersonation session with access token
     *
     * @example
     * ```typescript
     * const result = await client.admin.impersonation.impersonateUser({
     *   target_user_id: 'user-123',
     *   reason: 'Support ticket #5678 - user reports missing data'
     * })
     *
     * console.log('Impersonating:', result.target_user.email)
     * console.log('Session ID:', result.session.id)
     *
     * // Use the access token for subsequent requests
     * // (typically handled automatically by the SDK)
     * ```
     */
    async impersonateUser(request) {
      return await this.fetch.post("/api/v1/auth/impersonate", request);
    }
    /**
     * Impersonate anonymous user
     *
     * Start an impersonation session as an unauthenticated user. This allows you to see
     * what data is publicly accessible and test RLS policies for anonymous access.
     *
     * @param request - Impersonation request with reason
     * @returns Promise resolving to impersonation session with access token
     *
     * @example
     * ```typescript
     * await client.admin.impersonation.impersonateAnon({
     *   reason: 'Testing public data access for blog posts'
     * })
     *
     * // Now all queries will use anonymous permissions
     * const publicPosts = await client.from('posts').select('*')
     * console.log('Public posts:', publicPosts.length)
     * ```
     */
    async impersonateAnon(request) {
      return await this.fetch.post("/api/v1/auth/impersonate/anon", request);
    }
    /**
     * Impersonate with service role
     *
     * Start an impersonation session with service-level permissions. This provides elevated
     * access that may bypass RLS policies, useful for administrative operations.
     *
     * @param request - Impersonation request with reason
     * @returns Promise resolving to impersonation session with access token
     *
     * @example
     * ```typescript
     * await client.admin.impersonation.impersonateService({
     *   reason: 'Administrative data cleanup'
     * })
     *
     * // Now all queries will use service role permissions
     * const allRecords = await client.from('sensitive_data').select('*')
     * console.log('All records:', allRecords.length)
     * ```
     */
    async impersonateService(request) {
      return await this.fetch.post("/api/v1/auth/impersonate/service", request);
    }
    /**
     * Stop impersonation
     *
     * Ends the current impersonation session and returns to admin context.
     * The session is marked as ended in the audit trail.
     *
     * @returns Promise resolving to stop confirmation
     *
     * @example
     * ```typescript
     * await client.admin.impersonation.stop()
     * console.log('Impersonation ended')
     *
     * // Subsequent queries will use admin permissions
     * ```
     */
    async stop() {
      return await this.fetch.delete("/api/v1/auth/impersonate");
    }
    /**
     * Get current impersonation session
     *
     * Retrieves information about the active impersonation session, if any.
     *
     * @returns Promise resolving to current impersonation session or null
     *
     * @example
     * ```typescript
     * const current = await client.admin.impersonation.getCurrent()
     *
     * if (current.session) {
     *   console.log('Currently impersonating:', current.target_user?.email)
     *   console.log('Reason:', current.session.reason)
     *   console.log('Started:', current.session.started_at)
     * } else {
     *   console.log('No active impersonation')
     * }
     * ```
     */
    async getCurrent() {
      return await this.fetch.get("/api/v1/auth/impersonate");
    }
    /**
     * List impersonation sessions (audit trail)
     *
     * Retrieves a list of impersonation sessions for audit and compliance purposes.
     * Can be filtered by admin user, target user, type, and active status.
     *
     * @param options - Filter and pagination options
     * @returns Promise resolving to list of impersonation sessions
     *
     * @example
     * ```typescript
     * // List all sessions
     * const { sessions, total } = await client.admin.impersonation.listSessions()
     * console.log(`Total sessions: ${total}`)
     *
     * // List active sessions only
     * const active = await client.admin.impersonation.listSessions({
     *   is_active: true
     * })
     * console.log('Active sessions:', active.sessions.length)
     *
     * // List sessions for a specific admin
     * const adminSessions = await client.admin.impersonation.listSessions({
     *   admin_user_id: 'admin-uuid',
     *   limit: 50
     * })
     *
     * // List user impersonation sessions only
     * const userSessions = await client.admin.impersonation.listSessions({
     *   impersonation_type: 'user',
     *   offset: 0,
     *   limit: 100
     * })
     * ```
     *
     * @example
     * ```typescript
     * // Audit trail: Find who impersonated a specific user
     * const userHistory = await client.admin.impersonation.listSessions({
     *   target_user_id: 'user-uuid'
     * })
     *
     * userHistory.sessions.forEach(session => {
     *   console.log(`Admin ${session.admin_user_id} impersonated user`)
     *   console.log(`Reason: ${session.reason}`)
     *   console.log(`Duration: ${session.started_at} - ${session.ended_at}`)
     * })
     * ```
     */
    async listSessions(options = {}) {
      const params = new URLSearchParams();
      if (options.limit !== void 0) {
        params.append("limit", String(options.limit));
      }
      if (options.offset !== void 0) {
        params.append("offset", String(options.offset));
      }
      if (options.admin_user_id) {
        params.append("admin_user_id", options.admin_user_id);
      }
      if (options.target_user_id) {
        params.append("target_user_id", options.target_user_id);
      }
      if (options.impersonation_type) {
        params.append("impersonation_type", options.impersonation_type);
      }
      if (options.is_active !== void 0) {
        params.append("is_active", String(options.is_active));
      }
      const queryString = params.toString();
      const url = queryString ? `/api/v1/auth/impersonate/sessions?${queryString}` : "/api/v1/auth/impersonate/sessions";
      return await this.fetch.get(url);
    }
  };

  // src/management.ts
  var APIKeysManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Create a new API key
     *
     * @param request - API key configuration
     * @returns Created API key with the full key value (only shown once)
     *
     * @example
     * ```typescript
     * const { api_key, key } = await client.management.apiKeys.create({
     *   name: 'Production Service',
     *   description: 'API key for production service',
     *   scopes: ['read:users', 'write:users'],
     *   rate_limit_per_minute: 100,
     *   expires_at: '2025-12-31T23:59:59Z'
     * })
     *
     * // Store the key securely - it won't be shown again
     * console.log('API Key:', key)
     * ```
     */
    async create(request) {
      return await this.fetch.post("/api/v1/api-keys", request);
    }
    /**
     * List all API keys for the authenticated user
     *
     * @returns List of API keys (without full key values)
     *
     * @example
     * ```typescript
     * const { api_keys, total } = await client.management.apiKeys.list()
     *
     * api_keys.forEach(key => {
     *   console.log(`${key.name}: ${key.key_prefix}... (expires: ${key.expires_at})`)
     * })
     * ```
     */
    async list() {
      return await this.fetch.get("/api/v1/api-keys");
    }
    /**
     * Get a specific API key by ID
     *
     * @param keyId - API key ID
     * @returns API key details
     *
     * @example
     * ```typescript
     * const apiKey = await client.management.apiKeys.get('key-uuid')
     * console.log('Last used:', apiKey.last_used_at)
     * ```
     */
    async get(keyId) {
      return await this.fetch.get(`/api/v1/api-keys/${keyId}`);
    }
    /**
     * Update an API key
     *
     * @param keyId - API key ID
     * @param updates - Fields to update
     * @returns Updated API key
     *
     * @example
     * ```typescript
     * const updated = await client.management.apiKeys.update('key-uuid', {
     *   name: 'Updated Name',
     *   rate_limit_per_minute: 200
     * })
     * ```
     */
    async update(keyId, updates) {
      return await this.fetch.patch(`/api/v1/api-keys/${keyId}`, updates);
    }
    /**
     * Revoke an API key
     *
     * Revoked keys can no longer be used but remain in the system for audit purposes.
     *
     * @param keyId - API key ID
     * @returns Revocation confirmation
     *
     * @example
     * ```typescript
     * await client.management.apiKeys.revoke('key-uuid')
     * console.log('API key revoked')
     * ```
     */
    async revoke(keyId) {
      return await this.fetch.post(`/api/v1/api-keys/${keyId}/revoke`, {});
    }
    /**
     * Delete an API key
     *
     * Permanently removes the API key from the system.
     *
     * @param keyId - API key ID
     * @returns Deletion confirmation
     *
     * @example
     * ```typescript
     * await client.management.apiKeys.delete('key-uuid')
     * console.log('API key deleted')
     * ```
     */
    async delete(keyId) {
      return await this.fetch.delete(`/api/v1/api-keys/${keyId}`);
    }
  };
  var WebhooksManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Create a new webhook
     *
     * @param request - Webhook configuration
     * @returns Created webhook
     *
     * @example
     * ```typescript
     * const webhook = await client.management.webhooks.create({
     *   url: 'https://myapp.com/webhook',
     *   events: ['user.created', 'user.updated', 'user.deleted'],
     *   description: 'User events webhook',
     *   secret: 'my-webhook-secret'
     * })
     * ```
     */
    async create(request) {
      return await this.fetch.post("/api/v1/webhooks", request);
    }
    /**
     * List all webhooks for the authenticated user
     *
     * @returns List of webhooks
     *
     * @example
     * ```typescript
     * const { webhooks, total } = await client.management.webhooks.list()
     *
     * webhooks.forEach(webhook => {
     *   console.log(`${webhook.url}: ${webhook.is_active ? 'active' : 'inactive'}`)
     * })
     * ```
     */
    async list() {
      return await this.fetch.get("/api/v1/webhooks");
    }
    /**
     * Get a specific webhook by ID
     *
     * @param webhookId - Webhook ID
     * @returns Webhook details
     *
     * @example
     * ```typescript
     * const webhook = await client.management.webhooks.get('webhook-uuid')
     * console.log('Events:', webhook.events)
     * ```
     */
    async get(webhookId) {
      return await this.fetch.get(`/api/v1/webhooks/${webhookId}`);
    }
    /**
     * Update a webhook
     *
     * @param webhookId - Webhook ID
     * @param updates - Fields to update
     * @returns Updated webhook
     *
     * @example
     * ```typescript
     * const updated = await client.management.webhooks.update('webhook-uuid', {
     *   events: ['user.created', 'user.deleted'],
     *   is_active: false
     * })
     * ```
     */
    async update(webhookId, updates) {
      return await this.fetch.patch(`/api/v1/webhooks/${webhookId}`, updates);
    }
    /**
     * Delete a webhook
     *
     * @param webhookId - Webhook ID
     * @returns Deletion confirmation
     *
     * @example
     * ```typescript
     * await client.management.webhooks.delete('webhook-uuid')
     * console.log('Webhook deleted')
     * ```
     */
    async delete(webhookId) {
      return await this.fetch.delete(`/api/v1/webhooks/${webhookId}`);
    }
    /**
     * Test a webhook by sending a test payload
     *
     * @param webhookId - Webhook ID
     * @returns Test result with status and response
     *
     * @example
     * ```typescript
     * const result = await client.management.webhooks.test('webhook-uuid')
     *
     * if (result.success) {
     *   console.log('Webhook test successful')
     * } else {
     *   console.error('Webhook test failed:', result.error)
     * }
     * ```
     */
    async test(webhookId) {
      return await this.fetch.post(`/api/v1/webhooks/${webhookId}/test`, {});
    }
    /**
     * List webhook delivery history
     *
     * @param webhookId - Webhook ID
     * @param limit - Maximum number of deliveries to return (default: 50)
     * @returns List of webhook deliveries
     *
     * @example
     * ```typescript
     * const { deliveries } = await client.management.webhooks.listDeliveries('webhook-uuid', 100)
     *
     * deliveries.forEach(delivery => {
     *   console.log(`Event: ${delivery.event}, Status: ${delivery.status_code}`)
     * })
     * ```
     */
    async listDeliveries(webhookId, limit = 50) {
      return await this.fetch.get(
        `/api/v1/webhooks/${webhookId}/deliveries?limit=${limit}`
      );
    }
  };
  var InvitationsManager = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Create a new invitation (admin only)
     *
     * @param request - Invitation details
     * @returns Created invitation with invite link
     *
     * @example
     * ```typescript
     * const invitation = await client.management.invitations.create({
     *   email: 'newuser@example.com',
     *   role: 'dashboard_user',
     *   expiry_duration: 604800 // 7 days in seconds
     * })
     *
     * // Share the invite link
     * console.log('Send this link to the user:', invitation.invite_link)
     * ```
     */
    async create(request) {
      return await this.fetch.post("/api/v1/admin/invitations", request);
    }
    /**
     * List all invitations (admin only)
     *
     * @param options - Filter options
     * @returns List of invitations
     *
     * @example
     * ```typescript
     * // List pending invitations only
     * const { invitations } = await client.management.invitations.list({
     *   include_accepted: false,
     *   include_expired: false
     * })
     *
     * // List all invitations including accepted and expired
     * const all = await client.management.invitations.list({
     *   include_accepted: true,
     *   include_expired: true
     * })
     * ```
     */
    async list(options = {}) {
      const params = new URLSearchParams();
      if (options.include_accepted !== void 0) {
        params.append("include_accepted", String(options.include_accepted));
      }
      if (options.include_expired !== void 0) {
        params.append("include_expired", String(options.include_expired));
      }
      const queryString = params.toString();
      const url = queryString ? `/api/v1/admin/invitations?${queryString}` : "/api/v1/admin/invitations";
      return await this.fetch.get(url);
    }
    /**
     * Validate an invitation token (public endpoint)
     *
     * @param token - Invitation token
     * @returns Validation result with invitation details
     *
     * @example
     * ```typescript
     * const result = await client.management.invitations.validate('invitation-token')
     *
     * if (result.valid) {
     *   console.log('Valid invitation for:', result.invitation?.email)
     * } else {
     *   console.error('Invalid:', result.error)
     * }
     * ```
     */
    async validate(token) {
      return await this.fetch.get(`/api/v1/invitations/${token}/validate`);
    }
    /**
     * Accept an invitation and create a new user (public endpoint)
     *
     * @param token - Invitation token
     * @param request - User details (password and name)
     * @returns Created user with authentication tokens
     *
     * @example
     * ```typescript
     * const response = await client.management.invitations.accept('invitation-token', {
     *   password: 'SecurePassword123!',
     *   name: 'John Doe'
     * })
     *
     * // Store tokens
     * localStorage.setItem('access_token', response.access_token)
     * console.log('Welcome:', response.user.name)
     * ```
     */
    async accept(token, request) {
      return await this.fetch.post(`/api/v1/invitations/${token}/accept`, request);
    }
    /**
     * Revoke an invitation (admin only)
     *
     * @param token - Invitation token
     * @returns Revocation confirmation
     *
     * @example
     * ```typescript
     * await client.management.invitations.revoke('invitation-token')
     * console.log('Invitation revoked')
     * ```
     */
    async revoke(token) {
      return await this.fetch.delete(`/api/v1/admin/invitations/${token}`);
    }
  };
  var FluxbaseManagement = class {
    constructor(fetch2) {
      this.apiKeys = new APIKeysManager(fetch2);
      this.webhooks = new WebhooksManager(fetch2);
      this.invitations = new InvitationsManager(fetch2);
    }
  };

  // src/admin-functions.ts
  var FluxbaseAdminFunctions = class {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Create a new edge function
     *
     * @param request - Function configuration and code
     * @returns Promise resolving to { data, error } tuple with created function metadata
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.functions.create({
     *   name: 'my-function',
     *   code: 'export default async function handler(req) { return { hello: "world" } }',
     *   enabled: true
     * })
     * ```
     */
    async create(request) {
      try {
        const data = await this.fetch.post(
          "/api/v1/functions",
          request
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List all namespaces that have edge functions
     *
     * @returns Promise resolving to { data, error } tuple with array of namespace strings
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.functions.listNamespaces()
     * if (data) {
     *   console.log('Available namespaces:', data)
     * }
     * ```
     */
    async listNamespaces() {
      try {
        const response = await this.fetch.get(
          "/api/v1/admin/functions/namespaces"
        );
        return { data: response.namespaces || ["default"], error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List all edge functions (admin view)
     *
     * @param namespace - Optional namespace filter (if not provided, lists all public functions)
     * @returns Promise resolving to { data, error } tuple with array of functions
     *
     * @example
     * ```typescript
     * // List all public functions
     * const { data, error } = await client.admin.functions.list()
     *
     * // List functions in a specific namespace
     * const { data, error } = await client.admin.functions.list('my-namespace')
     * if (data) {
     *   console.log('Functions:', data.map(f => f.name))
     * }
     * ```
     */
    async list(namespace) {
      try {
        const params = namespace ? `?namespace=${namespace}` : "";
        const data = await this.fetch.get(
          `/api/v1/functions${params}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get details of a specific edge function
     *
     * @param name - Function name
     * @returns Promise resolving to { data, error } tuple with function metadata
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.functions.get('my-function')
     * if (data) {
     *   console.log('Function version:', data.version)
     * }
     * ```
     */
    async get(name) {
      try {
        const data = await this.fetch.get(
          `/api/v1/functions/${name}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Update an existing edge function
     *
     * @param name - Function name
     * @param updates - Fields to update
     * @returns Promise resolving to { data, error } tuple with updated function metadata
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.functions.update('my-function', {
     *   enabled: false,
     *   description: 'Updated description'
     * })
     * ```
     */
    async update(name, updates) {
      try {
        const data = await this.fetch.put(
          `/api/v1/functions/${name}`,
          updates
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Delete an edge function
     *
     * @param name - Function name
     * @returns Promise resolving to { data, error } tuple
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.functions.delete('my-function')
     * ```
     */
    async delete(name) {
      try {
        await this.fetch.delete(`/api/v1/functions/${name}`);
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get execution history for an edge function
     *
     * @param name - Function name
     * @param limit - Maximum number of executions to return (optional)
     * @returns Promise resolving to { data, error } tuple with execution records
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.functions.getExecutions('my-function', 10)
     * if (data) {
     *   data.forEach(exec => {
     *     console.log(`${exec.executed_at}: ${exec.status} (${exec.duration_ms}ms)`)
     *   })
     * }
     * ```
     */
    async getExecutions(name, limit) {
      try {
        const params = limit ? `?limit=${limit}` : "";
        const data = await this.fetch.get(
          `/api/v1/functions/${name}/executions${params}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Sync multiple functions to a namespace
     *
     * Bulk create/update/delete functions in a specific namespace. This is useful for
     * deploying functions from your application to Fluxbase in Kubernetes or other
     * container environments.
     *
     * Requires service_role or admin authentication.
     *
     * @param options - Sync configuration including namespace, functions, and options
     * @returns Promise resolving to { data, error } tuple with sync results
     *
     * @example
     * ```typescript
     * // Sync functions to "payment-service" namespace
     * const { data, error } = await client.admin.functions.sync({
     *   namespace: 'payment-service',
     *   functions: [
     *     {
     *       name: 'process-payment',
     *       code: 'export default async function handler(req) { ... }',
     *       enabled: true,
     *       allow_net: true
     *     },
     *     {
     *       name: 'refund-payment',
     *       code: 'export default async function handler(req) { ... }',
     *       enabled: true
     *     }
     *   ],
     *   options: {
     *     delete_missing: true  // Remove functions not in this list
     *   }
     * })
     *
     * if (data) {
     *   console.log(`Synced: ${data.summary.created} created, ${data.summary.updated} updated`)
     * }
     *
     * // Dry run to preview changes
     * const { data, error } = await client.admin.functions.sync({
     *   namespace: 'myapp',
     *   functions: [...],
     *   options: { dry_run: true }
     * })
     * ```
     */
    async sync(options) {
      try {
        const data = await this.fetch.post(
          "/api/v1/admin/functions/sync",
          options
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
  };

  // src/admin-migrations.ts
  var FluxbaseAdminMigrations = class {
    constructor(fetch2) {
      this.localMigrations = /* @__PURE__ */ new Map();
      this.fetch = fetch2;
    }
    /**
     * Register a migration locally for smart sync
     *
     * Call this method to register migrations in your application code.
     * When you call sync(), only new or changed migrations will be sent to the server.
     *
     * @param migration - Migration definition
     * @returns { error } tuple (always succeeds unless validation fails)
     *
     * @example
     * ```typescript
     * // In your app initialization
     * const { error: err1 } = client.admin.migrations.register({
     *   name: '001_create_users_table',
     *   namespace: 'myapp',
     *   up_sql: 'CREATE TABLE app.users (...)',
     *   down_sql: 'DROP TABLE app.users',
     *   description: 'Initial users table'
     * })
     *
     * const { error: err2 } = client.admin.migrations.register({
     *   name: '002_add_posts_table',
     *   namespace: 'myapp',
     *   up_sql: 'CREATE TABLE app.posts (...)',
     *   down_sql: 'DROP TABLE app.posts'
     * })
     *
     * // Sync all registered migrations
     * await client.admin.migrations.sync()
     * ```
     */
    register(migration) {
      try {
        if (!migration.name || !migration.up_sql) {
          return {
            error: new Error("Migration name and up_sql are required")
          };
        }
        const key = `${migration.namespace || "default"}:${migration.name}`;
        this.localMigrations.set(key, migration);
        return { error: null };
      } catch (error) {
        return { error };
      }
    }
    /**
     * Trigger schema refresh which will restart the server
     * Handles the restart gracefully by waiting for the server to come back online
     *
     * @private
     */
    async triggerSchemaRefreshWithRestart() {
      console.log("Triggering schema refresh (server will restart)...");
      try {
        const response = await this.fetch.post(
          "/api/v1/admin/schema/refresh",
          {}
        );
        console.log("Server restart initiated:", response.message || "Schema refresh in progress");
      } catch (error) {
        const isConnectionError = error.message?.includes("fetch failed") || error.message?.includes("ECONNREFUSED") || error.message?.includes("ECONNRESET") || error.code === "ECONNREFUSED" || error.code === "ECONNRESET";
        if (!isConnectionError) {
          throw error;
        }
        console.log("Connection dropped (expected during restart)...");
      }
      console.log("Waiting 6 seconds for server to restart...");
      await this.sleep(6e3);
      const maxAttempts = 5;
      const baseDelay = 1e3;
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          await this.fetch.get("/health");
          console.log("Server is back online and ready");
          return;
        } catch (error) {
          const isLastAttempt = attempt === maxAttempts;
          if (isLastAttempt) {
            throw new Error(
              `Server did not come back online after ${maxAttempts} attempts. Please check server logs and try again.`
            );
          }
          const delay = baseDelay * Math.pow(2, attempt - 1);
          console.log(`Server not ready yet, retrying in ${delay}ms... (attempt ${attempt}/${maxAttempts})`);
          await this.sleep(delay);
        }
      }
    }
    /**
     * Helper function to sleep for a given duration
     * @private
     */
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    /**
     * Smart sync all registered migrations
     *
     * Automatically determines which migrations need to be created or updated by:
     * 1. Fetching existing migrations from the server
     * 2. Comparing content hashes to detect changes
     * 3. Only sending new or changed migrations
     *
     * After successful sync, can optionally auto-apply new migrations and refresh
     * the server's schema cache.
     *
     * @param options - Sync options
     * @returns Promise resolving to { data, error } tuple with sync results
     *
     * @example
     * ```typescript
     * // Basic sync (idempotent - safe to call on every app startup)
     * const { data, error } = await client.admin.migrations.sync()
     * if (data) {
     *   console.log(`Created: ${data.summary.created}, Updated: ${data.summary.updated}`)
     * }
     *
     * // Sync with auto-apply (applies new migrations automatically)
     * const { data, error } = await client.admin.migrations.sync({
     *   auto_apply: true
     * })
     *
     * // Dry run to preview changes without applying
     * const { data, error } = await client.admin.migrations.sync({
     *   dry_run: true
     * })
     * ```
     */
    async sync(options = {}) {
      try {
        const byNamespace = /* @__PURE__ */ new Map();
        for (const migration of this.localMigrations.values()) {
          const ns = migration.namespace || "default";
          if (!byNamespace.has(ns)) {
            byNamespace.set(ns, []);
          }
          byNamespace.get(ns).push(migration);
        }
        const results = [];
        const errors = [];
        for (const [namespace, migrations] of byNamespace) {
          try {
            const result = await this.fetch.post(
              "/api/v1/admin/migrations/sync",
              {
                namespace,
                migrations: migrations.map((m) => ({
                  name: m.name,
                  description: m.description,
                  up_sql: m.up_sql,
                  down_sql: m.down_sql
                })),
                options: {
                  update_if_changed: options.update_if_changed ?? true,
                  auto_apply: options.auto_apply ?? false,
                  dry_run: options.dry_run ?? false
                }
              }
            );
            results.push(result);
          } catch (error) {
            const err = error;
            if (err.status === 422 && err.details) {
              results.push(err.details);
              errors.push(err);
            } else {
              throw error;
            }
          }
        }
        const combined = {
          message: results.map((r) => r.message).join("; "),
          namespace: Array.from(byNamespace.keys()).join(", "),
          summary: {
            created: results.reduce((sum, r) => sum + r.summary.created, 0),
            updated: results.reduce((sum, r) => sum + r.summary.updated, 0),
            unchanged: results.reduce((sum, r) => sum + r.summary.unchanged, 0),
            skipped: results.reduce((sum, r) => sum + r.summary.skipped, 0),
            applied: results.reduce((sum, r) => sum + r.summary.applied, 0),
            errors: results.reduce((sum, r) => sum + r.summary.errors, 0)
          },
          details: {
            created: results.flatMap((r) => r.details.created),
            updated: results.flatMap((r) => r.details.updated),
            unchanged: results.flatMap((r) => r.details.unchanged),
            skipped: results.flatMap((r) => r.details.skipped),
            applied: results.flatMap((r) => r.details.applied),
            errors: results.flatMap((r) => r.details.errors)
          },
          dry_run: options.dry_run ?? false,
          warnings: results.flatMap((r) => r.warnings || [])
        };
        const hasChanges = combined.summary.created > 0 || combined.summary.updated > 0;
        if (!combined.dry_run && hasChanges) {
          try {
            await this.triggerSchemaRefreshWithRestart();
          } catch (refreshError) {
            console.warn("Schema refresh completed with warnings:", refreshError);
          }
        }
        if (errors.length > 0 || combined.summary.errors > 0) {
          const error = new Error(combined.message);
          error.syncResult = combined;
          error.details = combined.details.errors;
          return { data: combined, error };
        }
        return { data: combined, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Create a new migration
     *
     * @param request - Migration configuration
     * @returns Promise resolving to { data, error } tuple with created migration
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.create({
     *   namespace: 'myapp',
     *   name: '001_create_users',
     *   up_sql: 'CREATE TABLE app.users (id UUID PRIMARY KEY, email TEXT)',
     *   down_sql: 'DROP TABLE app.users',
     *   description: 'Create users table'
     * })
     * ```
     */
    async create(request) {
      try {
        const data = await this.fetch.post("/api/v1/admin/migrations", request);
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List migrations in a namespace
     *
     * @param namespace - Migration namespace (default: 'default')
     * @param status - Filter by status: 'pending', 'applied', 'failed', 'rolled_back'
     * @returns Promise resolving to { data, error } tuple with migrations array
     *
     * @example
     * ```typescript
     * // List all migrations
     * const { data, error } = await client.admin.migrations.list('myapp')
     *
     * // List only pending migrations
     * const { data, error } = await client.admin.migrations.list('myapp', 'pending')
     * ```
     */
    async list(namespace = "default", status) {
      try {
        const params = new URLSearchParams({ namespace });
        if (status) params.append("status", status);
        const data = await this.fetch.get(
          `/api/v1/admin/migrations?${params.toString()}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get details of a specific migration
     *
     * @param name - Migration name
     * @param namespace - Migration namespace (default: 'default')
     * @returns Promise resolving to { data, error } tuple with migration details
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.get('001_create_users', 'myapp')
     * ```
     */
    async get(name, namespace = "default") {
      try {
        const params = new URLSearchParams({ namespace });
        const data = await this.fetch.get(
          `/api/v1/admin/migrations/${name}?${params.toString()}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Update a migration (only if status is pending)
     *
     * @param name - Migration name
     * @param updates - Fields to update
     * @param namespace - Migration namespace (default: 'default')
     * @returns Promise resolving to { data, error } tuple with updated migration
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.update(
     *   '001_create_users',
     *   { description: 'Updated description' },
     *   'myapp'
     * )
     * ```
     */
    async update(name, updates, namespace = "default") {
      try {
        const params = new URLSearchParams({ namespace });
        const data = await this.fetch.put(
          `/api/v1/admin/migrations/${name}?${params.toString()}`,
          updates
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Delete a migration (only if status is pending)
     *
     * @param name - Migration name
     * @param namespace - Migration namespace (default: 'default')
     * @returns Promise resolving to { data, error } tuple
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.delete('001_create_users', 'myapp')
     * ```
     */
    async delete(name, namespace = "default") {
      try {
        const params = new URLSearchParams({ namespace });
        await this.fetch.delete(`/api/v1/admin/migrations/${name}?${params.toString()}`);
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Apply a specific migration
     *
     * @param name - Migration name
     * @param namespace - Migration namespace (default: 'default')
     * @returns Promise resolving to { data, error } tuple with result message
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.apply('001_create_users', 'myapp')
     * if (data) {
     *   console.log(data.message) // "Migration applied successfully"
     * }
     * ```
     */
    async apply(name, namespace = "default") {
      try {
        const data = await this.fetch.post(
          `/api/v1/admin/migrations/${name}/apply`,
          { namespace }
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Rollback a specific migration
     *
     * @param name - Migration name
     * @param namespace - Migration namespace (default: 'default')
     * @returns Promise resolving to { data, error } tuple with result message
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.rollback('001_create_users', 'myapp')
     * ```
     */
    async rollback(name, namespace = "default") {
      try {
        const data = await this.fetch.post(
          `/api/v1/admin/migrations/${name}/rollback`,
          { namespace }
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Apply all pending migrations in order
     *
     * @param namespace - Migration namespace (default: 'default')
     * @returns Promise resolving to { data, error } tuple with applied/failed counts
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.applyPending('myapp')
     * if (data) {
     *   console.log(`Applied: ${data.applied.length}, Failed: ${data.failed.length}`)
     * }
     * ```
     */
    async applyPending(namespace = "default") {
      try {
        const data = await this.fetch.post("/api/v1/admin/migrations/apply-pending", { namespace });
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get execution history for a migration
     *
     * @param name - Migration name
     * @param namespace - Migration namespace (default: 'default')
     * @param limit - Maximum number of executions to return (default: 50, max: 100)
     * @returns Promise resolving to { data, error } tuple with execution records
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.migrations.getExecutions(
     *   '001_create_users',
     *   'myapp',
     *   10
     * )
     * if (data) {
     *   data.forEach(exec => {
     *     console.log(`${exec.executed_at}: ${exec.action} - ${exec.status}`)
     *   })
     * }
     * ```
     */
    async getExecutions(name, namespace = "default", limit = 50) {
      try {
        const params = new URLSearchParams({ namespace, limit: limit.toString() });
        const data = await this.fetch.get(
          `/api/v1/admin/migrations/${name}/executions?${params.toString()}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
  };

  // src/admin-jobs.ts
  var esbuild = null;
  async function loadEsbuild() {
    if (esbuild) return true;
    try {
      esbuild = await import("esbuild");
      return true;
    } catch {
      return false;
    }
  }
  var FluxbaseAdminJobs = class _FluxbaseAdminJobs {
    constructor(fetch2) {
      this.fetch = fetch2;
    }
    /**
     * Create a new job function
     *
     * @param request - Job function configuration and code
     * @returns Promise resolving to { data, error } tuple with created job function metadata
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.create({
     *   name: 'process-data',
     *   code: 'export async function handler(req) { return { success: true } }',
     *   enabled: true,
     *   timeout_seconds: 300
     * })
     * ```
     */
    async create(request) {
      try {
        const data = await this.fetch.post(
          "/api/v1/admin/jobs/functions",
          request
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List all namespaces that have job functions
     *
     * @returns Promise resolving to { data, error } tuple with array of namespace strings
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.listNamespaces()
     * if (data) {
     *   console.log('Available namespaces:', data)
     * }
     * ```
     */
    async listNamespaces() {
      try {
        const response = await this.fetch.get(
          "/api/v1/admin/jobs/namespaces"
        );
        return { data: response.namespaces || ["default"], error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List all job functions (admin view)
     *
     * @param namespace - Optional namespace filter
     * @returns Promise resolving to { data, error } tuple with array of job functions
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.list('default')
     * if (data) {
     *   console.log('Job functions:', data.map(f => f.name))
     * }
     * ```
     */
    async list(namespace) {
      try {
        const params = namespace ? `?namespace=${namespace}` : "";
        const data = await this.fetch.get(
          `/api/v1/admin/jobs/functions${params}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get details of a specific job function
     *
     * @param namespace - Namespace
     * @param name - Job function name
     * @returns Promise resolving to { data, error } tuple with job function metadata
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.get('default', 'process-data')
     * if (data) {
     *   console.log('Job function version:', data.version)
     * }
     * ```
     */
    async get(namespace, name) {
      try {
        const data = await this.fetch.get(
          `/api/v1/admin/jobs/functions/${namespace}/${name}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Update an existing job function
     *
     * @param namespace - Namespace
     * @param name - Job function name
     * @param updates - Fields to update
     * @returns Promise resolving to { data, error } tuple with updated job function metadata
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.update('default', 'process-data', {
     *   enabled: false,
     *   timeout_seconds: 600
     * })
     * ```
     */
    async update(namespace, name, updates) {
      try {
        const data = await this.fetch.put(
          `/api/v1/admin/jobs/functions/${namespace}/${name}`,
          updates
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Delete a job function
     *
     * @param namespace - Namespace
     * @param name - Job function name
     * @returns Promise resolving to { data, error } tuple
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.delete('default', 'process-data')
     * ```
     */
    async delete(namespace, name) {
      try {
        await this.fetch.delete(
          `/api/v1/admin/jobs/functions/${namespace}/${name}`
        );
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List all jobs (executions) across all namespaces (admin view)
     *
     * @param filters - Optional filters (status, namespace, limit, offset)
     * @returns Promise resolving to { data, error } tuple with array of jobs
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.listJobs({
     *   status: 'running',
     *   namespace: 'default',
     *   limit: 50
     * })
     * if (data) {
     *   data.forEach(job => {
     *     console.log(`${job.job_name}: ${job.status}`)
     *   })
     * }
     * ```
     */
    async listJobs(filters) {
      try {
        const params = new URLSearchParams();
        if (filters?.status) params.append("status", filters.status);
        if (filters?.namespace) params.append("namespace", filters.namespace);
        if (filters?.limit) params.append("limit", filters.limit.toString());
        if (filters?.offset) params.append("offset", filters.offset.toString());
        const queryString = params.toString();
        const data = await this.fetch.get(
          `/api/v1/admin/jobs/queue${queryString ? `?${queryString}` : ""}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get details of a specific job (execution)
     *
     * @param jobId - Job ID
     * @returns Promise resolving to { data, error } tuple with job details
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.getJob('550e8400-e29b-41d4-a716-446655440000')
     * if (data) {
     *   console.log(`Job ${data.job_name}: ${data.status}`)
     * }
     * ```
     */
    async getJob(jobId) {
      try {
        const data = await this.fetch.get(
          `/api/v1/admin/jobs/queue/${jobId}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Cancel a running or pending job
     *
     * @param jobId - Job ID
     * @returns Promise resolving to { data, error } tuple
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.cancel('550e8400-e29b-41d4-a716-446655440000')
     * ```
     */
    async cancel(jobId) {
      try {
        await this.fetch.post(`/api/v1/admin/jobs/queue/${jobId}/cancel`, {});
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Terminate a running job immediately
     *
     * @param jobId - Job ID
     * @returns Promise resolving to { data, error } tuple
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.terminate('550e8400-e29b-41d4-a716-446655440000')
     * ```
     */
    async terminate(jobId) {
      try {
        await this.fetch.post(`/api/v1/admin/jobs/queue/${jobId}/terminate`, {});
        return { data: null, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Retry a failed job
     *
     * @param jobId - Job ID
     * @returns Promise resolving to { data, error } tuple with new job
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.retry('550e8400-e29b-41d4-a716-446655440000')
     * ```
     */
    async retry(jobId) {
      try {
        const data = await this.fetch.post(
          `/api/v1/admin/jobs/queue/${jobId}/retry`,
          {}
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Get job statistics
     *
     * @param namespace - Optional namespace filter
     * @returns Promise resolving to { data, error } tuple with job stats
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.getStats('default')
     * if (data) {
     *   console.log(`Pending: ${data.pending}, Running: ${data.running}`)
     * }
     * ```
     */
    async getStats(namespace) {
      try {
        const params = namespace ? `?namespace=${namespace}` : "";
        const data = await this.fetch.get(
          `/api/v1/admin/jobs/stats${params}`
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * List active workers
     *
     * @returns Promise resolving to { data, error } tuple with array of workers
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.listWorkers()
     * if (data) {
     *   data.forEach(worker => {
     *     console.log(`Worker ${worker.id}: ${worker.current_jobs} jobs`)
     *   })
     * }
     * ```
     */
    async listWorkers() {
      try {
        const data = await this.fetch.get(
          "/api/v1/admin/jobs/workers"
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Sync multiple job functions to a namespace
     *
     * Can sync from:
     * 1. Filesystem (if no jobs provided) - loads from configured jobs directory
     * 2. API payload (if jobs array provided) - syncs provided job specifications
     *
     * Requires service_role or admin authentication.
     *
     * @param options - Sync options including namespace and optional jobs array
     * @returns Promise resolving to { data, error } tuple with sync results
     *
     * @example
     * ```typescript
     * // Sync from filesystem
     * const { data, error } = await client.admin.jobs.sync({ namespace: 'default' })
     *
     * // Sync with pre-bundled code (client-side bundling)
     * const bundled = await FluxbaseAdminJobs.bundleCode({ code: myJobCode })
     * const { data, error } = await client.admin.jobs.sync({
     *   namespace: 'default',
     *   functions: [{
     *     name: 'my-job',
     *     code: bundled.code,
     *     is_pre_bundled: true,
     *     original_code: myJobCode,
     *   }],
     *   options: {
     *     delete_missing: true, // Remove jobs not in this sync
     *     dry_run: false,       // Preview changes without applying
     *   }
     * })
     *
     * if (data) {
     *   console.log(`Synced: ${data.summary.created} created, ${data.summary.updated} updated`)
     * }
     * ```
     */
    async sync(options) {
      try {
        const syncOptions = typeof options === "string" ? { namespace: options } : options;
        const data = await this.fetch.post(
          "/api/v1/admin/jobs/sync",
          {
            namespace: syncOptions.namespace,
            jobs: syncOptions.functions,
            options: {
              delete_missing: syncOptions.options?.delete_missing ?? false,
              dry_run: syncOptions.options?.dry_run ?? false
            }
          }
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Sync job functions with automatic client-side bundling
     *
     * This is a convenience method that bundles all job code using esbuild
     * before sending to the server. Requires esbuild as a peer dependency.
     *
     * @param options - Sync options including namespace and jobs array
     * @param bundleOptions - Optional bundling configuration
     * @returns Promise resolving to { data, error } tuple with sync results
     *
     * @example
     * ```typescript
     * const { data, error } = await client.admin.jobs.syncWithBundling({
     *   namespace: 'default',
     *   functions: [
     *     { name: 'process-data', code: processDataCode },
     *     { name: 'send-email', code: sendEmailCode },
     *   ],
     *   options: { delete_missing: true }
     * })
     * ```
     */
    async syncWithBundling(options, bundleOptions) {
      if (!options.functions || options.functions.length === 0) {
        return this.sync(options);
      }
      const hasEsbuild = await loadEsbuild();
      if (!hasEsbuild) {
        return {
          data: null,
          error: new Error(
            "esbuild is required for client-side bundling. Install it with: npm install esbuild"
          )
        };
      }
      try {
        const bundledFunctions = await Promise.all(
          options.functions.map(async (fn) => {
            if (fn.is_pre_bundled) {
              return fn;
            }
            const bundled = await _FluxbaseAdminJobs.bundleCode({
              // Apply global bundle options first
              ...bundleOptions,
              // Then override with per-function values (these take priority)
              code: fn.code,
              // Use function's sourceDir for resolving relative imports
              baseDir: fn.sourceDir || bundleOptions?.baseDir,
              // Use function's nodePaths for additional module resolution
              nodePaths: fn.nodePaths || bundleOptions?.nodePaths
            });
            return {
              ...fn,
              code: bundled.code,
              original_code: fn.code,
              is_pre_bundled: true
            };
          })
        );
        return this.sync({
          ...options,
          functions: bundledFunctions
        });
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Bundle job code using esbuild (client-side)
     *
     * Transforms and bundles TypeScript/JavaScript code into a single file
     * that can be executed by the Fluxbase jobs runtime.
     *
     * Requires esbuild as a peer dependency.
     *
     * @param options - Bundle options including source code
     * @returns Promise resolving to bundled code
     * @throws Error if esbuild is not available
     *
     * @example
     * ```typescript
     * const bundled = await FluxbaseAdminJobs.bundleCode({
     *   code: `
     *     import { helper } from './utils'
     *     export async function handler(req) {
     *       return helper(req.payload)
     *     }
     *   `,
     *   minify: true,
     * })
     *
     * // Use bundled code in sync
     * await client.admin.jobs.sync({
     *   namespace: 'default',
     *   functions: [{
     *     name: 'my-job',
     *     code: bundled.code,
     *     is_pre_bundled: true,
     *   }]
     * })
     * ```
     */
    static async bundleCode(options) {
      const hasEsbuild = await loadEsbuild();
      if (!hasEsbuild || !esbuild) {
        throw new Error(
          "esbuild is required for bundling. Install it with: npm install esbuild"
        );
      }
      const externals = [...options.external ?? []];
      const alias = {};
      if (options.importMap) {
        for (const [key, value] of Object.entries(options.importMap)) {
          if (value.startsWith("npm:")) {
            externals.push(key);
          } else if (value.startsWith("https://") || value.startsWith("http://")) {
            externals.push(key);
          } else if (value.startsWith("/") || value.startsWith("./") || value.startsWith("../")) {
            alias[key] = value;
          } else {
            externals.push(key);
          }
        }
      }
      const denoExternalPlugin = {
        name: "deno-external",
        setup(build) {
          build.onResolve({ filter: /^npm:/ }, (args) => ({
            path: args.path,
            external: true
          }));
          build.onResolve({ filter: /^https?:\/\// }, (args) => ({
            path: args.path,
            external: true
          }));
          build.onResolve({ filter: /^jsr:/ }, (args) => ({
            path: args.path,
            external: true
          }));
        }
      };
      const resolveDir = options.baseDir || process.cwd?.() || "/";
      const buildOptions = {
        stdin: {
          contents: options.code,
          loader: "ts",
          resolveDir
        },
        // Set absWorkingDir for consistent path resolution
        absWorkingDir: resolveDir,
        bundle: true,
        write: false,
        format: "esm",
        // Use 'node' platform for better node_modules resolution (Deno supports Node APIs)
        platform: "node",
        target: "esnext",
        minify: options.minify ?? false,
        sourcemap: options.sourcemap ? "inline" : false,
        external: externals,
        plugins: [denoExternalPlugin],
        // Preserve handler export
        treeShaking: true,
        // Resolve .ts, .js, .mjs extensions
        resolveExtensions: [".ts", ".tsx", ".js", ".mjs", ".json"],
        // ESM conditions for better module resolution
        conditions: ["import", "module"]
      };
      if (Object.keys(alias).length > 0) {
        buildOptions.alias = alias;
      }
      if (options.nodePaths && options.nodePaths.length > 0) {
        buildOptions.nodePaths = options.nodePaths;
      }
      if (options.define) {
        buildOptions.define = options.define;
      }
      const result = await esbuild.build(buildOptions);
      const output = result.outputFiles?.[0];
      if (!output) {
        throw new Error("Bundling failed: no output generated");
      }
      return {
        code: output.text,
        sourceMap: options.sourcemap ? output.text : void 0
      };
    }
  };

  // src/admin.ts
  var FluxbaseAdmin = class {
    constructor(fetch2) {
      this.adminToken = null;
      this.fetch = fetch2;
      this.settings = new FluxbaseSettings(fetch2);
      this.ddl = new DDLManager(fetch2);
      this.oauth = new FluxbaseOAuth(fetch2);
      this.impersonation = new ImpersonationManager(fetch2);
      this.management = new FluxbaseManagement(fetch2);
      this.emailTemplates = new EmailTemplateManager(fetch2);
      this.functions = new FluxbaseAdminFunctions(fetch2);
      this.jobs = new FluxbaseAdminJobs(fetch2);
      this.migrations = new FluxbaseAdminMigrations(fetch2);
    }
    /**
     * Set admin authentication token
     */
    setToken(token) {
      this.adminToken = token;
      this.fetch.setAuthToken(token);
    }
    /**
     * Get current admin token
     */
    getToken() {
      return this.adminToken;
    }
    /**
     * Clear admin token
     */
    clearToken() {
      this.adminToken = null;
      this.fetch.setAuthToken(null);
    }
    // ============================================================================
    // Admin Authentication
    // ============================================================================
    /**
     * Check if initial admin setup is needed
     *
     * @returns Setup status indicating if initial setup is required
     *
     * @example
     * ```typescript
     * const status = await admin.getSetupStatus();
     * if (status.needs_setup) {
     *   console.log('Initial setup required');
     * }
     * ```
     */
    async getSetupStatus() {
      return wrapAsync(async () => {
        return await this.fetch.get(
          "/api/v1/admin/setup/status"
        );
      });
    }
    /**
     * Perform initial admin setup
     *
     * Creates the first admin user and completes initial setup.
     * This endpoint can only be called once.
     *
     * @param email - Admin email address
     * @param password - Admin password (minimum 12 characters)
     * @param name - Admin display name
     * @returns Authentication response with tokens
     *
     * @example
     * ```typescript
     * const response = await admin.setup({
     *   email: 'admin@example.com',
     *   password: 'SecurePassword123!',
     *   name: 'Admin User'
     * });
     *
     * // Store tokens
     * localStorage.setItem('admin_token', response.access_token);
     * ```
     */
    async setup(request) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/admin/setup",
          request
        );
        this.setToken(response.access_token);
        return response;
      });
    }
    /**
     * Admin login
     *
     * Authenticate as an admin user
     *
     * @param email - Admin email
     * @param password - Admin password
     * @returns Authentication response with tokens
     *
     * @example
     * ```typescript
     * const response = await admin.login({
     *   email: 'admin@example.com',
     *   password: 'password123'
     * });
     *
     * // Token is automatically set in the client
     * console.log('Logged in as:', response.user.email);
     * ```
     */
    async login(request) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/admin/login",
          request
        );
        this.setToken(response.access_token);
        return response;
      });
    }
    /**
     * Refresh admin access token
     *
     * @param refreshToken - Refresh token
     * @returns New access and refresh tokens
     *
     * @example
     * ```typescript
     * const refreshToken = localStorage.getItem('admin_refresh_token');
     * const response = await admin.refreshToken({ refresh_token: refreshToken });
     *
     * // Update stored tokens
     * localStorage.setItem('admin_token', response.access_token);
     * localStorage.setItem('admin_refresh_token', response.refresh_token);
     * ```
     */
    async refreshToken(request) {
      return wrapAsync(async () => {
        const response = await this.fetch.post(
          "/api/v1/admin/refresh",
          request
        );
        this.setToken(response.access_token);
        return response;
      });
    }
    /**
     * Admin logout
     *
     * Invalidates the current admin session
     *
     * @example
     * ```typescript
     * await admin.logout();
     * localStorage.removeItem('admin_token');
     * ```
     */
    async logout() {
      return wrapAsyncVoid(async () => {
        await this.fetch.post("/api/v1/admin/logout", {});
        this.clearToken();
      });
    }
    /**
     * Get current admin user information
     *
     * @returns Current admin user details
     *
     * @example
     * ```typescript
     * const { user } = await admin.me();
     * console.log('Logged in as:', user.email);
     * console.log('Role:', user.role);
     * ```
     */
    async me() {
      return wrapAsync(async () => {
        return await this.fetch.get("/api/v1/admin/me");
      });
    }
    // ============================================================================
    // User Management
    // ============================================================================
    /**
     * List all users
     *
     * @param options - Filter and pagination options
     * @returns List of users with metadata
     *
     * @example
     * ```typescript
     * // List all users
     * const { users, total } = await admin.listUsers();
     *
     * // List with filters
     * const result = await admin.listUsers({
     *   exclude_admins: true,
     *   search: 'john',
     *   limit: 50,
     *   type: 'app'
     * });
     * ```
     */
    async listUsers(options = {}) {
      return wrapAsync(async () => {
        const params = new URLSearchParams();
        if (options.exclude_admins !== void 0) {
          params.append("exclude_admins", String(options.exclude_admins));
        }
        if (options.search) {
          params.append("search", options.search);
        }
        if (options.limit !== void 0) {
          params.append("limit", String(options.limit));
        }
        if (options.type) {
          params.append("type", options.type);
        }
        const queryString = params.toString();
        const url = queryString ? `/api/v1/admin/users?${queryString}` : "/api/v1/admin/users";
        return await this.fetch.get(url);
      });
    }
    /**
     * Get a user by ID
     *
     * Fetch a single user's details by their user ID
     *
     * @param userId - User ID to fetch
     * @param type - User type ('app' or 'dashboard')
     * @returns User details with metadata
     *
     * @example
     * ```typescript
     * // Get an app user
     * const user = await admin.getUserById('user-123');
     *
     * // Get a dashboard user
     * const dashboardUser = await admin.getUserById('admin-456', 'dashboard');
     * console.log('User email:', dashboardUser.email);
     * console.log('Last login:', dashboardUser.last_login_at);
     * ```
     */
    async getUserById(userId, type = "app") {
      return wrapAsync(async () => {
        const url = `/api/v1/admin/users/${userId}?type=${type}`;
        return await this.fetch.get(url);
      });
    }
    /**
     * Invite a new user
     *
     * Creates a new user and optionally sends an invitation email
     *
     * @param request - User invitation details
     * @param type - User type ('app' or 'dashboard')
     * @returns Created user and invitation details
     *
     * @example
     * ```typescript
     * const response = await admin.inviteUser({
     *   email: 'newuser@example.com',
     *   role: 'user',
     *   send_email: true
     * });
     *
     * console.log('User invited:', response.user.email);
     * console.log('Invitation link:', response.invitation_link);
     * ```
     */
    async inviteUser(request, type = "app") {
      return wrapAsync(async () => {
        const url = `/api/v1/admin/users/invite?type=${type}`;
        return await this.fetch.post(url, request);
      });
    }
    /**
     * Delete a user
     *
     * Permanently deletes a user and all associated data
     *
     * @param userId - User ID to delete
     * @param type - User type ('app' or 'dashboard')
     * @returns Deletion confirmation
     *
     * @example
     * ```typescript
     * await admin.deleteUser('user-uuid');
     * console.log('User deleted');
     * ```
     */
    async deleteUser(userId, type = "app") {
      return wrapAsync(async () => {
        const url = `/api/v1/admin/users/${userId}?type=${type}`;
        return await this.fetch.delete(url);
      });
    }
    /**
     * Update user role
     *
     * Changes a user's role
     *
     * @param userId - User ID
     * @param role - New role
     * @param type - User type ('app' or 'dashboard')
     * @returns Updated user
     *
     * @example
     * ```typescript
     * const user = await admin.updateUserRole('user-uuid', 'admin');
     * console.log('User role updated:', user.role);
     * ```
     */
    async updateUserRole(userId, role, type = "app") {
      return wrapAsync(async () => {
        const url = `/api/v1/admin/users/${userId}/role?type=${type}`;
        return await this.fetch.patch(url, { role });
      });
    }
    /**
     * Reset user password
     *
     * Generates a new password for the user and optionally sends it via email
     *
     * @param userId - User ID
     * @param type - User type ('app' or 'dashboard')
     * @returns Reset confirmation message
     *
     * @example
     * ```typescript
     * const response = await admin.resetUserPassword('user-uuid');
     * console.log(response.message);
     * ```
     */
    async resetUserPassword(userId, type = "app") {
      return wrapAsync(async () => {
        const url = `/api/v1/admin/users/${userId}/reset-password?type=${type}`;
        return await this.fetch.post(url, {});
      });
    }
  };

  // src/query-builder.ts
  var QueryBuilder = class {
    constructor(fetch2, table, schema) {
      this.selectQuery = "*";
      this.filters = [];
      this.orFilters = [];
      this.andFilters = [];
      this.orderBys = [];
      this.singleRow = false;
      this.maybeSingleRow = false;
      this.operationType = "select";
      this.headOnly = false;
      this.fetch = fetch2;
      this.table = table;
      this.schema = schema;
    }
    /**
     * Build the API path for this table, including schema if specified
     */
    buildTablePath() {
      return this.schema ? `/api/v1/tables/${this.schema}/${this.table}` : `/api/v1/tables/${this.table}`;
    }
    /**
     * Select columns to return
     * @example select('*')
     * @example select('id, name, email')
     * @example select('id, name, posts(title, content)')
     * @example select('*', { count: 'exact' }) // Get exact count
     * @example select('*', { count: 'exact', head: true }) // Get count only (no data)
     */
    select(columns = "*", options) {
      this.selectQuery = columns;
      if (options?.count) {
        this.countType = options.count;
      }
      if (options?.head) {
        this.headOnly = true;
      }
      return this;
    }
    /**
     * Insert a single row or multiple rows
     */
    insert(data) {
      this.operationType = "insert";
      this.insertData = data;
      return this;
    }
    /**
     * Upsert (insert or update) rows (Supabase-compatible)
     * @param data - Row(s) to upsert
     * @param options - Upsert options (onConflict, ignoreDuplicates, defaultToNull)
     */
    async upsert(data, options) {
      const body = Array.isArray(data) ? data : data;
      const preferValues = [];
      if (options?.ignoreDuplicates) {
        preferValues.push("resolution=ignore-duplicates");
      } else {
        preferValues.push("resolution=merge-duplicates");
      }
      if (options?.defaultToNull) {
        preferValues.push("missing=default");
      }
      const headers = {
        Prefer: preferValues.join(",")
      };
      let path = this.buildTablePath();
      if (options?.onConflict) {
        path += `?on_conflict=${encodeURIComponent(options.onConflict)}`;
      }
      const response = await this.fetch.post(path, body, { headers });
      return {
        data: response,
        error: null,
        count: Array.isArray(data) ? data.length : 1,
        status: 201,
        statusText: "Created"
      };
    }
    /**
     * Update rows matching the filters
     */
    update(data) {
      this.operationType = "update";
      this.updateData = data;
      return this;
    }
    /**
     * Delete rows matching the filters
     */
    delete() {
      this.operationType = "delete";
      return this;
    }
    /**
     * Equal to
     */
    eq(column, value) {
      this.filters.push({ column, operator: "eq", value });
      return this;
    }
    /**
     * Not equal to
     */
    neq(column, value) {
      this.filters.push({ column, operator: "neq", value });
      return this;
    }
    /**
     * Greater than
     */
    gt(column, value) {
      this.filters.push({ column, operator: "gt", value });
      return this;
    }
    /**
     * Greater than or equal to
     */
    gte(column, value) {
      this.filters.push({ column, operator: "gte", value });
      return this;
    }
    /**
     * Less than
     */
    lt(column, value) {
      this.filters.push({ column, operator: "lt", value });
      return this;
    }
    /**
     * Less than or equal to
     */
    lte(column, value) {
      this.filters.push({ column, operator: "lte", value });
      return this;
    }
    /**
     * Pattern matching (case-sensitive)
     */
    like(column, pattern) {
      this.filters.push({ column, operator: "like", value: pattern });
      return this;
    }
    /**
     * Pattern matching (case-insensitive)
     */
    ilike(column, pattern) {
      this.filters.push({ column, operator: "ilike", value: pattern });
      return this;
    }
    /**
     * Check if value is null or not null
     */
    is(column, value) {
      this.filters.push({ column, operator: "is", value });
      return this;
    }
    /**
     * Check if value is in array
     */
    in(column, values) {
      this.filters.push({ column, operator: "in", value: values });
      return this;
    }
    /**
     * Contains (for arrays and JSONB)
     */
    contains(column, value) {
      this.filters.push({ column, operator: "cs", value });
      return this;
    }
    /**
     * Full-text search
     */
    textSearch(column, query) {
      this.filters.push({ column, operator: "fts", value: query });
      return this;
    }
    /**
     * Negate a filter condition (Supabase-compatible)
     * @example not('status', 'eq', 'deleted')
     * @example not('completed_at', 'is', null)
     */
    not(column, operator, value) {
      this.filters.push({
        column,
        operator: "not",
        value: `${operator}.${this.formatValue(value)}`
      });
      return this;
    }
    /**
     * Apply OR logic to filters (Supabase-compatible)
     * @example or('status.eq.active,status.eq.pending')
     * @example or('id.eq.2,name.eq.Han')
     */
    or(filters) {
      this.orFilters.push(filters);
      return this;
    }
    /**
     * Apply AND logic to filters (Supabase-compatible)
     * Groups multiple conditions that must all be true
     * @example and('status.eq.active,verified.eq.true')
     * @example and('age.gte.18,age.lte.65')
     */
    and(filters) {
      this.andFilters.push(filters);
      return this;
    }
    /**
     * Match multiple columns with exact values (Supabase-compatible)
     * Shorthand for multiple .eq() calls
     * @example match({ id: 1, status: 'active', role: 'admin' })
     */
    match(conditions) {
      for (const [column, value] of Object.entries(conditions)) {
        this.eq(column, value);
      }
      return this;
    }
    /**
     * Generic filter method using PostgREST syntax (Supabase-compatible)
     * @example filter('name', 'in', '("Han","Yoda")')
     * @example filter('age', 'gte', '18')
     */
    filter(column, operator, value) {
      this.filters.push({ column, operator, value });
      return this;
    }
    /**
     * Check if column is contained by value (Supabase-compatible)
     * For arrays and JSONB
     * @example containedBy('tags', '["news","update"]')
     */
    containedBy(column, value) {
      this.filters.push({ column, operator: "cd", value });
      return this;
    }
    /**
     * Check if arrays have common elements (Supabase-compatible)
     * @example overlaps('tags', '["news","sports"]')
     */
    overlaps(column, value) {
      this.filters.push({ column, operator: "ov", value });
      return this;
    }
    // PostGIS Spatial Query Methods
    /**
     * Check if geometries intersect (PostGIS ST_Intersects)
     * @param column - Column containing geometry/geography data
     * @param geojson - GeoJSON object to test intersection with
     * @example intersects('location', { type: 'Point', coordinates: [-122.4, 37.8] })
     */
    intersects(column, geojson) {
      this.filters.push({
        column,
        operator: "st_intersects",
        value: geojson
      });
      return this;
    }
    /**
     * Check if geometry A contains geometry B (PostGIS ST_Contains)
     * @param column - Column containing geometry/geography data
     * @param geojson - GeoJSON object to test containment
     * @example contains('region', { type: 'Point', coordinates: [-122.4, 37.8] })
     */
    stContains(column, geojson) {
      this.filters.push({
        column,
        operator: "st_contains",
        value: geojson
      });
      return this;
    }
    /**
     * Check if geometry A is within geometry B (PostGIS ST_Within)
     * @param column - Column containing geometry/geography data
     * @param geojson - GeoJSON object to test containment within
     * @example within('point', { type: 'Polygon', coordinates: [[...]] })
     */
    within(column, geojson) {
      this.filters.push({
        column,
        operator: "st_within",
        value: geojson
      });
      return this;
    }
    /**
     * Check if geometries touch (PostGIS ST_Touches)
     * @param column - Column containing geometry/geography data
     * @param geojson - GeoJSON object to test touching
     * @example touches('boundary', { type: 'LineString', coordinates: [[...]] })
     */
    touches(column, geojson) {
      this.filters.push({
        column,
        operator: "st_touches",
        value: geojson
      });
      return this;
    }
    /**
     * Check if geometries cross (PostGIS ST_Crosses)
     * @param column - Column containing geometry/geography data
     * @param geojson - GeoJSON object to test crossing
     * @example crosses('road', { type: 'LineString', coordinates: [[...]] })
     */
    crosses(column, geojson) {
      this.filters.push({
        column,
        operator: "st_crosses",
        value: geojson
      });
      return this;
    }
    /**
     * Check if geometries spatially overlap (PostGIS ST_Overlaps)
     * @param column - Column containing geometry/geography data
     * @param geojson - GeoJSON object to test overlap
     * @example stOverlaps('area', { type: 'Polygon', coordinates: [[...]] })
     */
    stOverlaps(column, geojson) {
      this.filters.push({
        column,
        operator: "st_overlaps",
        value: geojson
      });
      return this;
    }
    /**
     * Order results
     */
    order(column, options) {
      this.orderBys.push({
        column,
        direction: options?.ascending === false ? "desc" : "asc",
        nulls: options?.nullsFirst ? "first" : "last"
      });
      return this;
    }
    /**
     * Limit number of rows returned
     */
    limit(count) {
      this.limitValue = count;
      return this;
    }
    /**
     * Skip rows
     */
    offset(count) {
      this.offsetValue = count;
      return this;
    }
    /**
     * Return a single row (adds limit(1))
     * Errors if no rows found
     */
    single() {
      this.singleRow = true;
      this.limitValue = 1;
      return this;
    }
    /**
     * Return a single row or null (adds limit(1))
     * Does not error if no rows found (Supabase-compatible)
     * @example
     * ```typescript
     * // Returns null instead of erroring when no row exists
     * const { data, error } = await client
     *   .from('users')
     *   .select('*')
     *   .eq('id', 999)
     *   .maybeSingle()
     * // data will be null if no row found
     * ```
     */
    maybeSingle() {
      this.maybeSingleRow = true;
      this.limitValue = 1;
      return this;
    }
    /**
     * Range selection (pagination)
     */
    range(from, to) {
      this.offsetValue = from;
      this.limitValue = to - from + 1;
      return this;
    }
    /**
     * Group results by one or more columns (for use with aggregations)
     *
     * @param columns - Column name(s) to group by
     * @returns Query builder for chaining
     *
     * @example
     * ```typescript
     * // Group by single column
     * const { data } = await client.from('orders')
     *   .count('*')
     *   .groupBy('status')
     *   .execute()
     *
     * // Group by multiple columns
     * const { data } = await client.from('sales')
     *   .sum('amount')
     *   .groupBy(['region', 'product_category'])
     *   .execute()
     * ```
     *
     * @category Aggregation
     */
    groupBy(columns) {
      this.groupByColumns = Array.isArray(columns) ? columns : [columns];
      return this;
    }
    /**
     * Count rows or a specific column
     *
     * @param column - Column to count (default: '*' for row count)
     * @returns Query builder for chaining
     *
     * @example
     * ```typescript
     * // Count all rows
     * const { data } = await client.from('users').count().execute()
     * // Returns: { count: 150 }
     *
     * // Count non-null values in a column
     * const { data } = await client.from('orders').count('completed_at').execute()
     *
     * // Count with grouping
     * const { data } = await client.from('products')
     *   .count('*')
     *   .groupBy('category')
     *   .execute()
     * // Returns: [{ category: 'electronics', count: 45 }, { category: 'books', count: 23 }]
     * ```
     *
     * @category Aggregation
     */
    count(column = "*") {
      this.selectQuery = `count(${column})`;
      return this;
    }
    /**
     * Calculate the sum of a numeric column
     *
     * @param column - Column to sum
     * @returns Query builder for chaining
     *
     * @example
     * ```typescript
     * // Sum all prices
     * const { data } = await client.from('products').sum('price').execute()
     * // Returns: { sum_price: 15420.50 }
     *
     * // Sum by category
     * const { data } = await client.from('orders')
     *   .sum('total')
     *   .groupBy('status')
     *   .execute()
     * // Returns: [{ status: 'completed', sum_total: 12500 }, { status: 'pending', sum_total: 3200 }]
     * ```
     *
     * @category Aggregation
     */
    sum(column) {
      this.selectQuery = `sum(${column})`;
      return this;
    }
    /**
     * Calculate the average of a numeric column
     *
     * @param column - Column to average
     * @returns Query builder for chaining
     *
     * @example
     * ```typescript
     * // Average price
     * const { data } = await client.from('products').avg('price').execute()
     * // Returns: { avg_price: 129.99 }
     *
     * // Average by category
     * const { data } = await client.from('products')
     *   .avg('price')
     *   .groupBy('category')
     *   .execute()
     * ```
     *
     * @category Aggregation
     */
    avg(column) {
      this.selectQuery = `avg(${column})`;
      return this;
    }
    /**
     * Find the minimum value in a column
     *
     * @param column - Column to find minimum value
     * @returns Query builder for chaining
     *
     * @example
     * ```typescript
     * // Find lowest price
     * const { data } = await client.from('products').min('price').execute()
     * // Returns: { min_price: 9.99 }
     *
     * // Find earliest date
     * const { data } = await client.from('orders').min('created_at').execute()
     * ```
     *
     * @category Aggregation
     */
    min(column) {
      this.selectQuery = `min(${column})`;
      return this;
    }
    /**
     * Find the maximum value in a column
     *
     * @param column - Column to find maximum value
     * @returns Query builder for chaining
     *
     * @example
     * ```typescript
     * // Find highest price
     * const { data } = await client.from('products').max('price').execute()
     * // Returns: { max_price: 1999.99 }
     *
     * // Find most recent order
     * const { data } = await client.from('orders').max('created_at').execute()
     * ```
     *
     * @category Aggregation
     */
    max(column) {
      this.selectQuery = `max(${column})`;
      return this;
    }
    /**
     * Insert multiple rows in a single request (batch insert)
     *
     * This is a convenience method that explicitly shows intent for batch operations.
     * Internally calls `insert()` with an array.
     *
     * @param rows - Array of row objects to insert
     * @returns Promise with the inserted rows
     *
     * @example
     * ```typescript
     * // Insert multiple users at once
     * const { data } = await client.from('users').insertMany([
     *   { name: 'Alice', email: 'alice@example.com' },
     *   { name: 'Bob', email: 'bob@example.com' },
     *   { name: 'Charlie', email: 'charlie@example.com' }
     * ])
     * ```
     *
     * @category Batch Operations
     */
    async insertMany(rows) {
      return this.insert(rows).execute();
    }
    /**
     * Update multiple rows matching the filters (batch update)
     *
     * Updates all rows that match the current query filters.
     * This is a convenience method that explicitly shows intent for batch operations.
     *
     * @param data - Data to update matching rows with
     * @returns Promise with the updated rows
     *
     * @example
     * ```typescript
     * // Apply discount to all electronics
     * const { data } = await client.from('products')
     *   .eq('category', 'electronics')
     *   .updateMany({ discount: 10, updated_at: new Date() })
     *
     * // Mark all pending orders as processing
     * const { data } = await client.from('orders')
     *   .eq('status', 'pending')
     *   .updateMany({ status: 'processing' })
     * ```
     *
     * @category Batch Operations
     */
    async updateMany(data) {
      return this.update(data).execute();
    }
    /**
     * Delete multiple rows matching the filters (batch delete)
     *
     * Deletes all rows that match the current query filters.
     * This is a convenience method that explicitly shows intent for batch operations.
     *
     * @returns Promise confirming deletion
     *
     * @example
     * ```typescript
     * // Delete all inactive users
     * await client.from('users')
     *   .eq('active', false)
     *   .deleteMany()
     *
     * // Delete old logs
     * await client.from('logs')
     *   .lt('created_at', '2024-01-01')
     *   .deleteMany()
     * ```
     *
     * @category Batch Operations
     */
    async deleteMany() {
      return this.delete().execute();
    }
    /**
     * Execute the query and return results
     */
    async execute() {
      try {
        if (this.operationType === "insert") {
          if (!this.insertData) {
            throw new Error("Insert data is required for insert operation");
          }
          const body = Array.isArray(this.insertData) ? this.insertData : this.insertData;
          const response = await this.fetch.post(this.buildTablePath(), body);
          return {
            data: response,
            error: null,
            count: Array.isArray(this.insertData) ? this.insertData.length : 1,
            status: 201,
            statusText: "Created"
          };
        }
        if (this.operationType === "update") {
          if (!this.updateData) {
            throw new Error("Update data is required for update operation");
          }
          const queryString2 = this.buildQueryString();
          const path2 = `${this.buildTablePath()}${queryString2}`;
          const response = await this.fetch.patch(path2, this.updateData);
          return {
            data: response,
            error: null,
            count: null,
            status: 200,
            statusText: "OK"
          };
        }
        if (this.operationType === "delete") {
          const queryString2 = this.buildQueryString();
          const path2 = `${this.buildTablePath()}${queryString2}`;
          await this.fetch.delete(path2);
          return {
            data: null,
            error: null,
            count: null,
            status: 204,
            statusText: "No Content"
          };
        }
        const queryString = this.buildQueryString();
        const path = `${this.buildTablePath()}${queryString}`;
        if (this.countType) {
          const response = await this.fetch.getWithHeaders(path);
          const serverCount = this.parseContentRangeCount(response.headers);
          const data2 = response.data;
          if (this.headOnly) {
            return {
              data: null,
              error: null,
              count: serverCount,
              status: response.status,
              statusText: "OK"
            };
          }
          if (this.singleRow) {
            if (Array.isArray(data2) && data2.length === 0) {
              return {
                data: null,
                error: { message: "No rows found", code: "PGRST116" },
                count: serverCount ?? 0,
                status: 404,
                statusText: "Not Found"
              };
            }
            const singleData = Array.isArray(data2) ? data2[0] : data2;
            return {
              data: singleData,
              error: null,
              count: serverCount ?? 1,
              status: 200,
              statusText: "OK"
            };
          }
          if (this.maybeSingleRow) {
            if (Array.isArray(data2) && data2.length === 0) {
              return {
                data: null,
                error: null,
                count: serverCount ?? 0,
                status: 200,
                statusText: "OK"
              };
            }
            const singleData = Array.isArray(data2) ? data2[0] : data2;
            return {
              data: singleData,
              error: null,
              count: serverCount ?? 1,
              status: 200,
              statusText: "OK"
            };
          }
          return {
            data: data2,
            error: null,
            count: serverCount ?? (Array.isArray(data2) ? data2.length : null),
            status: 200,
            statusText: "OK"
          };
        }
        const data = await this.fetch.get(path);
        if (this.singleRow) {
          if (Array.isArray(data) && data.length === 0) {
            return {
              data: null,
              error: { message: "No rows found", code: "PGRST116" },
              count: 0,
              status: 404,
              statusText: "Not Found"
            };
          }
          const singleData = Array.isArray(data) ? data[0] : data;
          return {
            data: singleData,
            error: null,
            count: 1,
            status: 200,
            statusText: "OK"
          };
        }
        if (this.maybeSingleRow) {
          if (Array.isArray(data) && data.length === 0) {
            return {
              data: null,
              error: null,
              count: 0,
              status: 200,
              statusText: "OK"
            };
          }
          const singleData = Array.isArray(data) ? data[0] : data;
          return {
            data: singleData,
            error: null,
            count: 1,
            status: 200,
            statusText: "OK"
          };
        }
        return {
          data,
          error: null,
          count: Array.isArray(data) ? data.length : null,
          status: 200,
          statusText: "OK"
        };
      } catch (err) {
        const error = err;
        return {
          data: null,
          error: {
            message: error.message,
            code: "PGRST000"
          },
          count: null,
          status: 500,
          statusText: "Internal Server Error"
        };
      }
    }
    /**
     * Execute the query and throw an error if one occurs (Supabase-compatible)
     * Returns the data directly instead of { data, error } wrapper
     *
     * @throws {Error} If the query fails or returns an error
     * @example
     * ```typescript
     * // Throws error instead of returning { data, error }
     * try {
     *   const user = await client
     *     .from('users')
     *     .select('*')
     *     .eq('id', 1)
     *     .single()
     *     .throwOnError()
     * } catch (error) {
     *   console.error('Query failed:', error)
     * }
     * ```
     */
    async throwOnError() {
      const response = await this.execute();
      if (response.error) {
        const error = new Error(response.error.message);
        if (response.error.code) {
          error.code = response.error.code;
        }
        throw error;
      }
      return response.data;
    }
    /**
     * Make QueryBuilder awaitable (implements PromiseLike)
     * This allows using `await client.from('table').select()` without calling `.execute()`
     *
     * @example
     * ```typescript
     * // Without .execute() (new way)
     * const { data } = await client.from('users').select('*')
     *
     * // With .execute() (old way, still supported)
     * const { data } = await client.from('users').select('*').execute()
     * ```
     */
    then(onfulfilled, onrejected) {
      return this.execute().then(onfulfilled, onrejected);
    }
    /**
     * Build the query string from filters, ordering, etc.
     */
    buildQueryString() {
      const params = new URLSearchParams();
      if (this.selectQuery && this.selectQuery !== "*") {
        params.append("select", this.selectQuery);
      }
      for (const filter of this.filters) {
        params.append(
          filter.column,
          `${filter.operator}.${this.formatValue(filter.value)}`
        );
      }
      for (const orFilter of this.orFilters) {
        params.append("or", `(${orFilter})`);
      }
      for (const andFilter of this.andFilters) {
        params.append("and", `(${andFilter})`);
      }
      if (this.groupByColumns && this.groupByColumns.length > 0) {
        params.append("group_by", this.groupByColumns.join(","));
      }
      if (this.orderBys.length > 0) {
        const orderStr = this.orderBys.map(
          (o) => `${o.column}.${o.direction}${o.nulls ? `.nulls${o.nulls}` : ""}`
        ).join(",");
        params.append("order", orderStr);
      }
      if (this.limitValue !== void 0) {
        params.append("limit", String(this.limitValue));
      }
      if (this.offsetValue !== void 0) {
        params.append("offset", String(this.offsetValue));
      }
      if (this.countType) {
        params.append("count", this.countType);
      }
      const queryString = params.toString();
      return queryString ? `?${queryString}` : "";
    }
    /**
     * Format a value for the query string
     */
    formatValue(value) {
      if (value === null) {
        return "null";
      }
      if (typeof value === "boolean") {
        return value ? "true" : "false";
      }
      if (Array.isArray(value)) {
        return `(${value.map((v) => this.formatValue(v)).join(",")})`;
      }
      if (typeof value === "object") {
        return JSON.stringify(value);
      }
      return String(value);
    }
    /**
     * Parse the Content-Range header to extract the total count
     * Header format: "0-999/50000" or "* /50000" (when no rows returned)
     */
    parseContentRangeCount(headers) {
      const contentRange = headers.get("Content-Range");
      if (!contentRange) {
        return null;
      }
      const match = contentRange.match(/\/(\d+)$/);
      if (match && match[1]) {
        return parseInt(match[1], 10);
      }
      return null;
    }
  };

  // src/schema-query-builder.ts
  var SchemaQueryBuilder = class {
    constructor(fetch2, schemaName) {
      this.fetch = fetch2;
      this.schemaName = schemaName;
    }
    /**
     * Create a query builder for a table in this schema
     *
     * @param table - The table name (without schema prefix)
     * @returns A query builder instance for constructing and executing queries
     */
    from(table) {
      return new QueryBuilder(this.fetch, table, this.schemaName);
    }
  };

  // src/client.ts
  var FluxbaseClient = class {
    /**
     * Create a new Fluxbase client instance
     *
     * @param fluxbaseUrl - The URL of your Fluxbase instance
     * @param fluxbaseKey - The anon key (JWT token with "anon" role). Generate using scripts/generate-keys.sh
     * @param options - Additional client configuration options
     *
     * @example
     * ```typescript
     * const client = new FluxbaseClient(
     *   'http://localhost:8080',
     *   'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',  // Anon JWT token
     *   { timeout: 30000 }
     * )
     * ```
     */
    constructor(fluxbaseUrl, fluxbaseKey, options) {
      this.fluxbaseUrl = fluxbaseUrl;
      this.fluxbaseKey = fluxbaseKey;
      const headers = {
        apikey: fluxbaseKey,
        Authorization: `Bearer ${fluxbaseKey}`,
        ...options?.headers
      };
      this.fetch = new FluxbaseFetch(fluxbaseUrl, {
        headers,
        timeout: options?.timeout,
        debug: options?.debug
      });
      this.fetch.setAnonKey(fluxbaseKey);
      this.auth = new FluxbaseAuth(
        this.fetch,
        options?.auth?.autoRefresh ?? true,
        options?.auth?.persist ?? true
      );
      if (options?.auth?.token) {
        this.fetch.setAuthToken(options.auth.token);
      }
      this.realtime = new FluxbaseRealtime(
        fluxbaseUrl,
        options?.auth?.token || null
      );
      this.storage = new FluxbaseStorage(this.fetch);
      this.functions = new FluxbaseFunctions(this.fetch);
      this.jobs = new FluxbaseJobs(this.fetch);
      this.admin = new FluxbaseAdmin(this.fetch);
      this.management = new FluxbaseManagement(this.fetch);
      this.settings = new SettingsClient(this.fetch);
      this.setupAuthSync();
    }
    /**
     * Create a query builder for a database table
     *
     * @param table - The table name (can include schema, e.g., 'public.users')
     * @returns A query builder instance for constructing and executing queries
     *
     * @example
     * ```typescript
     * // Simple select
     * const { data } = await client.from('users').select('*').execute()
     *
     * // With filters
     * const { data } = await client.from('products')
     *   .select('id, name, price')
     *   .gt('price', 100)
     *   .eq('category', 'electronics')
     *   .execute()
     *
     * // Insert
     * await client.from('users').insert({ name: 'John', email: 'john@example.com' }).execute()
     * ```
     *
     * @category Database
     */
    from(table) {
      return new QueryBuilder(this.fetch, table);
    }
    /**
     * Access a specific database schema
     *
     * Use this to query tables in non-public schemas.
     *
     * @param schemaName - The schema name (e.g., 'jobs', 'analytics')
     * @returns A schema query builder for constructing queries on that schema
     *
     * @example
     * ```typescript
     * // Query the jobs.execution_logs table
     * const { data } = await client
     *   .schema('jobs')
     *   .from('execution_logs')
     *   .select('*')
     *   .eq('job_id', jobId)
     *   .execute()
     *
     * // Insert into a custom schema table
     * await client
     *   .schema('analytics')
     *   .from('events')
     *   .insert({ event_type: 'click', data: {} })
     *   .execute()
     * ```
     *
     * @category Database
     */
    schema(schemaName) {
      return new SchemaQueryBuilder(this.fetch, schemaName);
    }
    /**
     * Call a PostgreSQL function (Remote Procedure Call)
     *
     * @param functionName - The name of the PostgreSQL function to call
     * @param params - Optional parameters to pass to the function
     * @returns Promise containing the function result or error
     *
     * @example
     * ```typescript
     * // Call a function without parameters
     * const { data, error } = await client.rpc('get_total_users')
     *
     * // Call a function with parameters
     * const { data, error } = await client.rpc('calculate_discount', {
     *   product_id: 123,
     *   coupon_code: 'SAVE20'
     * })
     * ```
     *
     * @category Database
     */
    async rpc(functionName, params) {
      try {
        const data = await this.fetch.post(
          `/api/v1/rpc/${functionName}`,
          params || {}
        );
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    }
    /**
     * Sync auth state with realtime connections
     * @internal
     */
    setupAuthSync() {
      const originalSetAuthToken = this.fetch.setAuthToken.bind(this.fetch);
      this.fetch.setAuthToken = (token) => {
        originalSetAuthToken(token);
        this.realtime.setAuth(token);
      };
      this.realtime.setTokenRefreshCallback(async () => {
        const result = await this.auth.refreshSession();
        if (result.error || !result.data?.session) {
          console.error("[Fluxbase] Failed to refresh token for realtime:", result.error);
          return null;
        }
        return result.data.session.access_token;
      });
    }
    /**
     * Get the current authentication token
     *
     * @returns The current JWT access token, or null if not authenticated
     *
     * @category Authentication
     */
    getAuthToken() {
      return this.auth.getAccessToken();
    }
    /**
     * Set a new authentication token
     *
     * This updates both the HTTP client and realtime connection with the new token.
     *
     * @param token - The JWT access token to set, or null to clear authentication
     *
     * @category Authentication
     */
    setAuthToken(token) {
      this.fetch.setAuthToken(token);
      this.realtime.setAuth(token);
    }
    /**
     * Create or get a realtime channel (Supabase-compatible)
     *
     * @param name - Channel name
     * @param config - Optional channel configuration
     * @returns RealtimeChannel instance
     *
     * @example
     * ```typescript
     * const channel = client.channel('room-1', {
     *   broadcast: { self: true },
     *   presence: { key: 'user-123' }
     * })
     *   .on('broadcast', { event: 'message' }, (payload) => {
     *     console.log('Message:', payload)
     *   })
     *   .subscribe()
     * ```
     *
     * @category Realtime
     */
    channel(name, config) {
      return this.realtime.channel(name, config);
    }
    /**
     * Remove a realtime channel (Supabase-compatible)
     *
     * @param channel - The channel to remove
     * @returns Promise resolving to status
     *
     * @example
     * ```typescript
     * const channel = client.channel('room-1')
     * await client.removeChannel(channel)
     * ```
     *
     * @category Realtime
     */
    removeChannel(channel) {
      return this.realtime.removeChannel(channel);
    }
    /**
     * Get the internal HTTP client
     *
     * Use this for advanced scenarios like making custom API calls or admin operations.
     *
     * @returns The internal FluxbaseFetch instance
     *
     * @example
     * ```typescript
     * // Make a custom API call
     * const data = await client.http.get('/api/custom-endpoint')
     * ```
     *
     * @category Advanced
     */
    get http() {
      return this.fetch;
    }
  };
  function getEnvVar(name) {
    if (typeof process !== "undefined" && process.env) {
      return process.env[name];
    }
    if (typeof Deno !== "undefined" && Deno?.env) {
      return Deno.env.get(name);
    }
    return void 0;
  }
  function createClient(fluxbaseUrl, fluxbaseKey, options) {
    const url = fluxbaseUrl || getEnvVar("FLUXBASE_URL") || getEnvVar("NEXT_PUBLIC_FLUXBASE_URL") || getEnvVar("VITE_FLUXBASE_URL");
    const key = fluxbaseKey || getEnvVar("FLUXBASE_ANON_KEY") || getEnvVar("FLUXBASE_SERVICE_TOKEN") || getEnvVar("FLUXBASE_JOB_TOKEN") || getEnvVar("NEXT_PUBLIC_FLUXBASE_ANON_KEY") || getEnvVar("VITE_FLUXBASE_ANON_KEY");
    if (!url) {
      throw new Error(
        "Fluxbase URL is required. Pass it as the first argument or set FLUXBASE_URL environment variable."
      );
    }
    if (!key) {
      throw new Error(
        "Fluxbase key is required. Pass it as the second argument or set FLUXBASE_ANON_KEY environment variable."
      );
    }
    return new FluxbaseClient(url, key, options);
  }
  return __toCommonJS(embedded_entry_exports);
})();

// Create pre-configured client using environment variables
function _createFluxbaseClient(url, token, clientName) {
  if (!url || !token) {
    console.error('[Fluxbase SDK] ' + clientName + ': Missing URL or token');
    return null;
  }
  try {
    return _FluxbaseSDK.createClient(url, token);
  } catch (e) {
    console.error('[Fluxbase SDK] ' + clientName + ': Failed to create client:', e.message);
    return null;
  }
}

// Expose createClient globally for user code
const createClient = _FluxbaseSDK.createClient;
