package e2e

import (
	"context"
	"os"
	"testing"

	"github.com/rs/zerolog/log"
	"github.com/wayli-app/fluxbase/internal/config"
	"github.com/wayli-app/fluxbase/internal/database"
	"github.com/wayli-app/fluxbase/test"
)

// getDatabase creates a database connection for setup/teardown
func getDatabase(cfg *config.Config) (*database.Connection, error) {
	return database.NewConnection(cfg.Database)
}

// TestMain runs before all tests to set up test tables and after all tests to clean up
func TestMain(m *testing.M) {
	// Setup: Create test tables before running tests
	setupTestTables()

	// Run all tests
	code := m.Run()

	// Teardown: Clean up test tables after all tests complete
	teardownTestTables()

	// Exit with the test result code
	os.Exit(code)
}

// setupTestTables creates the test tables needed for e2e tests
func setupTestTables() {
	ctx := context.Background()

	// Get database connection using fluxbase_app (has BYPASSRLS for setup)
	cfg := test.GetTestConfig()
	db, err := getDatabase(cfg)
	if err != nil {
		log.Error().Err(err).Msg("Failed to connect to database for test setup")
		return
	}
	defer db.Close()

	log.Info().Msg("Setting up e2e test tables...")

	// Create products table for REST tests
	_, err = db.Exec(ctx, `
		CREATE TABLE IF NOT EXISTS public.products (
			id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
			name TEXT NOT NULL,
			price NUMERIC(10, 2) NOT NULL,
			created_at TIMESTAMPTZ DEFAULT NOW(),
			updated_at TIMESTAMPTZ DEFAULT NOW()
		)
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create products table")
		return
	}

	// Create trigger for products updated_at
	_, err = db.Exec(ctx, `
		CREATE TRIGGER update_products_updated_at
		BEFORE UPDATE ON public.products
		FOR EACH ROW
		EXECUTE FUNCTION public.update_updated_at()
	`)
	if err != nil {
		// Trigger might already exist, log but continue
		log.Debug().Err(err).Msg("Products trigger may already exist")
	}

	// Create tasks table for RLS tests
	_, err = db.Exec(ctx, `
		CREATE TABLE IF NOT EXISTS public.tasks (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
			title TEXT NOT NULL,
			description TEXT,
			completed BOOLEAN DEFAULT FALSE,
			is_public BOOLEAN DEFAULT FALSE,
			created_at TIMESTAMPTZ DEFAULT NOW(),
			updated_at TIMESTAMPTZ DEFAULT NOW()
		)
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create tasks table")
		return
	}

	// Create trigger for tasks updated_at
	_, err = db.Exec(ctx, `
		CREATE TRIGGER update_tasks_updated_at
		BEFORE UPDATE ON public.tasks
		FOR EACH ROW
		EXECUTE FUNCTION public.update_updated_at()
	`)
	if err != nil {
		log.Debug().Err(err).Msg("Tasks trigger may already exist")
	}

	// Enable RLS on tasks table
	_, err = db.Exec(ctx, `ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY`)
	if err != nil {
		log.Debug().Err(err).Msg("RLS may already be enabled on tasks")
	}

	// Force RLS even for table owner (required for testing)
	_, err = db.Exec(ctx, `ALTER TABLE public.tasks FORCE ROW LEVEL SECURITY`)
	if err != nil {
		log.Debug().Err(err).Msg("FORCE RLS may already be enabled on tasks")
	}

	// Drop existing RLS policies if they exist (to avoid conflicts)
	db.Exec(ctx, `DROP POLICY IF EXISTS tasks_select_own ON public.tasks`)
	db.Exec(ctx, `DROP POLICY IF EXISTS tasks_insert_own ON public.tasks`)
	db.Exec(ctx, `DROP POLICY IF EXISTS tasks_update_own ON public.tasks`)
	db.Exec(ctx, `DROP POLICY IF EXISTS tasks_delete_own ON public.tasks`)

	// Create RLS policies for tasks
	_, err = db.Exec(ctx, `
		CREATE POLICY tasks_select_own ON public.tasks
		FOR SELECT
		USING (user_id = auth.current_user_id() OR is_public = true)
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create tasks_select_own policy")
	}

	_, err = db.Exec(ctx, `
		CREATE POLICY tasks_insert_own ON public.tasks
		FOR INSERT
		WITH CHECK (user_id = auth.current_user_id())
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create tasks_insert_own policy")
	}

	_, err = db.Exec(ctx, `
		CREATE POLICY tasks_update_own ON public.tasks
		FOR UPDATE
		USING (user_id = auth.current_user_id())
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create tasks_update_own policy")
	}

	_, err = db.Exec(ctx, `
		CREATE POLICY tasks_delete_own ON public.tasks
		FOR DELETE
		USING (user_id = auth.current_user_id())
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create tasks_delete_own policy")
	}

	// Grant permissions to fluxbase_rls_test user for testing RLS
	// This must be done as postgres superuser since fluxbase_app doesn't own the schemas
	grantRLSTestPermissions()

	log.Info().Msg("E2E test tables setup complete")
}

// grantRLSTestPermissions grants permissions to the fluxbase_rls_test user
// This must be done as postgres superuser
func grantRLSTestPermissions() {
	ctx := context.Background()

	// Connect as postgres superuser to grant permissions
	// fluxbase_app cannot grant permissions on schemas it doesn't own
	cfg := test.GetTestConfig()
	cfg.Database.User = "postgres"
	cfg.Database.Password = "postgres"

	db, err := getDatabase(cfg)
	if err != nil {
		log.Error().Err(err).Msg("Failed to connect as postgres for granting permissions")
		return
	}
	defer db.Close()

	// Grant schema permissions
	_, err = db.Exec(ctx, `
		GRANT USAGE, CREATE ON SCHEMA auth TO fluxbase_rls_test;
		GRANT USAGE ON SCHEMA dashboard TO fluxbase_rls_test;
		GRANT USAGE ON SCHEMA functions TO fluxbase_rls_test;
		GRANT USAGE ON SCHEMA storage TO fluxbase_rls_test;
		GRANT USAGE ON SCHEMA realtime TO fluxbase_rls_test;
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to grant schema permissions to fluxbase_rls_test user")
		return
	}

	// Grant table and sequence permissions
	_, err = db.Exec(ctx, `
		GRANT ALL ON ALL TABLES IN SCHEMA auth TO fluxbase_rls_test;
		GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO fluxbase_rls_test;
		GRANT ALL ON ALL TABLES IN SCHEMA dashboard TO fluxbase_rls_test;
		GRANT ALL ON ALL SEQUENCES IN SCHEMA dashboard TO fluxbase_rls_test;
		GRANT ALL ON ALL TABLES IN SCHEMA functions TO fluxbase_rls_test;
		GRANT ALL ON ALL SEQUENCES IN SCHEMA functions TO fluxbase_rls_test;
		GRANT ALL ON ALL TABLES IN SCHEMA storage TO fluxbase_rls_test;
		GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO fluxbase_rls_test;
		GRANT ALL ON ALL TABLES IN SCHEMA realtime TO fluxbase_rls_test;
		GRANT ALL ON ALL SEQUENCES IN SCHEMA realtime TO fluxbase_rls_test;
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to grant table/sequence permissions to fluxbase_rls_test user")
		return
	}

	// Grant function execution permissions
	_, err = db.Exec(ctx, `
		GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA functions TO fluxbase_rls_test;
	`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to grant function execution permissions to fluxbase_rls_test user")
	}
}

// teardownTestTables drops the test tables after all tests complete
func teardownTestTables() {
	ctx := context.Background()

	// Get database connection
	cfg := test.GetTestConfig()
	db, err := getDatabase(cfg)
	if err != nil {
		log.Error().Err(err).Msg("Failed to connect to database for test teardown")
		return
	}
	defer db.Close()

	log.Info().Msg("Tearing down e2e test tables...")

	// Drop test tables
	_, err = db.Exec(ctx, `DROP TABLE IF EXISTS public.products CASCADE`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to drop products table")
	}

	_, err = db.Exec(ctx, `DROP TABLE IF EXISTS public.tasks CASCADE`)
	if err != nil {
		log.Error().Err(err).Msg("Failed to drop tasks table")
	}

	log.Info().Msg("E2E test tables teardown complete")
}
